# c语言
## 字符函数
<ctype.h>库的常用函数

| 函数名       | 是下列参数时,返回真                                                           |
| ------------ | ----------------------------------------------------------------------------- |
| `isalnum()`  | 字母或者数字                                                                  |
| `isalpha()`  | 字母                                                                          |
| `isdigit()`  | 数字                                                                          |
| `islower()`  | 小写字母                                                                      |
| `isupper()`  | 大写字母                                                                      |
| isblank()    | 标准的空白符(空格,水平制表符或换行符)或者任其他本地话指定为空白的字符           |
| iscntrl()    | 控制字符,如Ctrl+B                                                             |
| isgraph()    | 除了空格外的任意可打印字符                                                    |
| isprint()    | 可打印字符                                                                    |
| ispunct()    | 标点符号(除空格或字母数字字符以外的任意可打印字符)                            |
| isspace()    | 空白字符(空格,换行符,换页符,回车符,垂直制表符,水平制表符或其他本地化定义字符) |
| isxdigit()   | 十六进制数字符                                                                |
| ----------   | --------------                                                                |
| `tolower() ` | 如果参数是大写字符,该函数返回小写字符,否则返回原始参数                        |
| `toupper()`  | 如果参数是小写字符,该函数返回大写字符,否则返回原始参数                        |


## 输入输出函数

用`scanf()`读取字符串时,遇到空格字符就会停止  
但是可以使用`scanf("%[^\n]s",buf)`,表示读取到`\n`才会结束,来读取一行

### gets()与puts()
```c
gets(buf);
/*
会读取一行,直到读取到\n,但不会保存\n,会将输入缓冲区的\n丢弃,并在字符串后面添加\0
*/
puts(buf);
/*
输出时会自动换行
*/
```
### fgets()/fputs()

其函数定义为
```c
char *fgets(char*s,int size,FILE *stream);
/*
s        为保存到哪里,并且会读取\n并将换行放到目标地址中
size     最大保存的字符数,为size-1个,会自动添加\0
stream   读取来源,输入框里面用 stdin
*/
int fputs(const char*s,FILE *stream);
/*
s        输出的地址
stream   读取来源,输出到输出框里面用 stdout
*/
```
使用为
```c
fgets(buf,sizeof(buf),stdin);
/*
会读取一行,并且会读取\n并将换行放到目标地址中
而且会自动在地址末尾中添加\0,所以说最多读取size-1个字符
大于size的字符会存在缓冲区中
*/
fputs(buf,stdout);
/*
自己不会输出\n
*/
```

fputs() 和 puts() 有两个小区别：  
1. puts() 只能向标准输出流输出，而 fputs() 可以向任何流输出。  
2. 使用 puts() 时，系统会在自动在其后添加换行符；而使用 fputs() 时，系统不会自动添加换行符。

<!-- 2023年07月20日 -->
## 字符串和字符串数组
### 字符串数组和字符串常量

```c
char buf[1024]="hello 2023";//字符串数组
char *p="gcctest";//字符串常量
```
字符串数组内的元素能更改  
字符串常量属于静态存储类别,保存在代码段,在内存中只存在一份不能修改  
同一个字符串常量只会被存储一次

## 字符串函数
### 字符串长度 - strlen
```c
strlen(buf);
/*
会返回buf的长度,直到运行到\0的地方就会停止
*/
```
### 字符串相等比较函数 - strcmp,strncmp
```c
char buf1[1024]="123";
char buf2[1024]="123";
if(buf1 == buf2)//比较的buf1和buf2的地址
    printf("buf1 == buf2:相等");
if(!strcmp(buf1,buf2))//比较的buf1和buf2的内容
    printf("strcmp(buf1,buf2):相等");
/*
用strcmp时
    相等返回0
    不相等返回对应位数不相等的字符ASCII的差,buf1[n]-buf2[n],一直进行到一个buf到\0
*/

//strncmp(buf1,buf2,10);
/*
会比较buf1和buf2前10个字符
    相等就返回0;
    不相等就返回对应位数不相等的字符ASCII的差
*/
```

### 拼接两个字符串 - strcat,strncat

```c
//函数原型
char* strcat(char* dest, const char* src);
char* strncat(char* dest, const char* src, size_t n);
/*
char* dest：        目标位置
const char* src     源字符串位置
size_t n            表示最大从源位置拼接的字符的个数
返回目标地址dest
将源字符串附加到目标位置
*/
```
`strncat`使用时,会将src中n个元素与`\0`添加到dest后,共添加n+1个元素  
字符串不能重叠（不能自己拼接自己）  
dest字符串必须有足够的空间来容纳结果。如果dest不够大，则程序行为是不可预测的；  
应当保证 dest空间大小>=dest长度+src长度+1  

### 拷贝字符串 - strcpy,strncpy
```c
//函数原型
char* strcpy(char* dest, const char* src);
char* strncpy(char* dest, const char* src, size_t n);
/*
char* dest        目标缓冲区。
const char* src    源字符串。
size_t n            从src字符串中最多拷贝几个字符。
返回目标地址dest
复制src指向的字符串到dest字符串中，包括终止null字节('\0')
*/
```
dest空间大小至少为src长度(包括`\0`)  
可以自己复制自己1,但不建议这样用

### 字符串查找 - strstr
查找haystack中，needle第一次出现的位置，并返回。也就是说，查找字串needle在haystack第一次出现的位置，然后返回它。
```c
// 函数原型
char* strstr(const char* haystack, const char* needle);
/*
const char* haystack：被查找的字符串。
const char* needle：查找的子串。
返回needle在haystack中第一次出现的地址/位置。
如果没找到，就返回NULL
*/

```
### 字符串格式输入出 - sprintf,sscanf
```c
//函数原型
int sprintf(char *str, const char *format, ...);

char str[20];
int a=20984,b=48090;
sprintf(str,"%3d%6d",a,b); //str[]="20984 48090";
//打印到字符串中


int sscanf(const char *str, const char *format, ...);
```
只要在printf中可以使用的格式化字符串，在sprintf都可以使用。其中的格式化字符串是此函数的精华。

sprintf 用于将数据格式化写入字符串中，sscanf 用于从字符串中解析格式化数据。
### 字符查找 - strchr,strrchr
```c
//函数原型
char *strchr(const char *s, int c);
/*
返回第一次查找到的字符
未查找到就返回NULL
*/
char *strrchr(const char * s, int c);
/*
该函数返回s字符串中c字符的最后一次 出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到c字符，则返回空指针。
*/
```
`strchr()`是从前往后查找  
`strrchr()`是从后往前查找  

### 字符串查找 - strpbrk
```c
//函数原型
char *strpbrk(const char * s1, const char * s2);
/*
如果 s1 字符中包含 s2 字符 串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在s1字符 串中未找到任何s2字符串中的字符，则返回空字符。
*/
```
### 字符串切割 - strtok
```c
//函数原型
char * strtok ( char * str, const char * delim);
/*
返 回 值： 
    返回值为char * 类型 。如果找到标记，则为指向标记开头的指针。否则为空指针。当在正在扫描的字符串中达到字符串的末尾（即空字符）时，始终返回空指针。
函数参数说明： 
    sep参数是个字符串，定义了用作分隔符的字符集合。第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。 
剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。
在每个后续调用中，解析相同的字符串时，str 必须为 NULL。
    delim 参数指定一组字节，用于分隔已分析字符串中的标记。 调用方可以在解析同一字符串的连续调用中指定不同的字符串。
*/
 char buf[1024]="the,name,du,he";
    char*p=NULL;
    p=strtok(buf,",");
    printf("%s\n",p);
    while(p=strtok(NULL,","))
        printf("%s\n",p);
/*
会打印
the
name
du
he
*/
```

### 字符串转十进制数值类型
#### 转int - atoi()
```c
//函数原型
int atoi(const char *nptr);
long atol(const char *nptr);
long long atoll(const char *nptr);
```
把字符串转换成int类型的值。

#### 转long - atol()
```c
//函数原型
int atoi(const char *nptr);
long atol(const char *nptr);
long long atoll(const char *nptr);
```
把字符串转换成long类型的值。

#### 转double - atof()
```c
//函数原型
double atof(const char *nptr);
```
把字符串转换成double类型的值。

### 字符串转多进制数值类型

#### 转long - strtol()
```c
//函数原型
long strtol(const char *nptr, char **endptr, int base);
long long strtoll(const char *nptr, char **endptr, int base);
/*
nptr是指向待转换字符串的指针，
endptr是一个指针的地址，该指针被设置为标识输入数字结束字符的地址，终止的地址
base表示以什么进制写入数 字
*/
```
把字符串转换成long类型的值，可以指定转换为数字后的进制格式。

转译 nptr 所指的字节字符串中的整数值。

- 舍弃所有空白符（以调用 isspace() 鉴别），直到找到首个非空白符，然后取尽可能多的字符组成底 n （其中 n=base ）的整数表示，并将它们转换成一个整数值。合法的整数值由下列部分组成：
    - (可选)正或负号
    - (可选)指示八进制底的前缀（ 0 ）（仅当底为 8 或 ​0​ 时应用）
    - (可选)指示十六进制底的前缀（ 0x 或 0X ）（仅当底为 16 或 ​0​ 时应用）
    - 一个数字序列

底的合法集是 {0,2,3,...,36} 。合法数字集对于底 2 整数是 {0,1}，对于底3整数是 {0,1,2} ，以此类推。对于大于 10 的底，合法数字包含字母字符，从对于底 11 整数的 Aa 到对于底36整数的 Zz 。忽略字符大小写。

若 base 为 ​0​ ，则自动检测数值进制：若前缀为 0 ，则底为八进制，若前缀为 0x 或 0X ，则底为十六进制，否则底为十进制。

若符号是输入序列的一部分，则对从数字序列计算得来的数字值取反，如同用结果类型的一元减。

函数设置 endptr 所指向的指针指向最后被转译字符的后一字符。若 endptr 为空指针，则忽略它。

若 nptr 为空或无期待的形式，则不进行转换，并（若 endptr 不是空指针）将 nptr 的值存储于 endptr 所指的对象。


#### 转unsigned long - strtoul()
```c
//函数原型
unsigned long strtoul(const char *nptr, char **endptr, int base);
unsigned long long strtoull(const char *nptr, char **endptr,int base);

char buf[1024]="123456789";
char *p=NULL:
long l=strtol(buf,&p,8);
printf("l=%ld,p=%s\n",l,p);
//l=342391,p=89
```
把字符串转换unsigned long类型的值，可以指定转换为数字后的进制格式。

#### 转double - strtod()
```c
//函数原型
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
```
把字符串转换成 double类型的值。


## 动态内存分配
### 创建和释放内存

```c
 #include <stdlib.h>
void *malloc(size_t size);
void free(void *ptr);

int *p=(int *)mallloc(sizeof(int));
free(p);
/*
malloc和free要配套使用
    malloc给内存
    free销毁内存
*/
```
void*为万能指针,  
但可以将其他指针赋值给void*  
但不可以将void*赋值给其他指针(应该使用强转)  

当`free()`函数接收的是NULL时,函数不进行任何操作

既不能多free,也不能少free

`calloc()`和`malloc()`函数类似,但参数不同

动态分配的内存默认是随机的,需要自己手动初始化
### 内存操作函数
```c
//函数原型
void *memset(void *s, int c, size_t n);
//将s的内存区域的前n个字节以参数c填入
/*
    s：需要操作内存s的首地址
	c：填充的字符，c虽然参数为int，但必须是unsigned char , 范围为0~255
	n：指定需要设置的大小
返回s的首地址

逐字节赋值,每个字节8位
*/

//函数原型
void *memcpy(void *dest, const void *src, size_t n);
//拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。
/*
    dest：目的内存首地址
	src：源内存首地址，注意：dest和src所指的内存空间不可重叠，可能会导致程序报错
	n：需要拷贝的字节数
返回dest的首地址
*/

//函数原型
int memcmp(const void *s1, const void *s2, size_t n);
//比较s1和s2所指向内存区域的前n个字节
/*
    s1：内存首地址1
	s2：内存首地址2
	n：需比较的前n个字节
返回值：
	相等：=0
	大于：>0
	小于：<0
*/

//函数原型
void *memmove(void *dest, const void *src, size_t n);
/*
memmove()功能用法和memcpy()一样，
区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些。
*/
```

## 随机数

### 随机数生成函数：rand()
```c
int rand(void);
//功能：返回0至RAND_MAX之间的随机数值，RAND_MAX定义在stdlib.h，其值为2147483647。

```
### 随机数发生器的初始化函数srand()
```c
void srand(unsigned int seed);
//功能：用来设置rand()产生随机数时的随机种子
//参数：如果每次seed相等，rand()产生随机数相等
time_t time(time_t *t);
//功能：获取当前系统时间，（从1970年1月1日到此刻的秒数）
//返回值：当前系统时间, time_t 相当于long类型，单位为毫秒
```

## 文件的操作函数

c语言自带`FILE`结构体  
`FILE`是系统使用`typedef`定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。  
一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作
```c
typedef struct 
{
	short           level;		//缓冲区"满"或者"空"的程度 
	unsigned        flags;	//文件状态标志 
	char            fd;		//文件描述符
	unsigned char   hold;	//如无缓冲区不读取字符
	short           	bsize;	//缓冲区的大小
	unsigned char   *buffer;	//数据缓冲区的位置 
	unsigned        ar;	 	//指针，当前的指向 
	unsigned        istemp;	//临时文件，指示器
	short           token;	//用于有效性的检查 
}FILE;
```

读写文件的步骤
1. 打开文件 - fopen()
2. 读/写文件 - fread()/fwrite()
3. 关闭文件 - fclose

### 打开文件
```c
//函数原型
FILE * fopen(const char * filename, const char * mode);
/*
	filename：需要打开的文件名，根据需要加上路径,既可以绝对,也可以相对路径
	mode：打开文件的模式设置
返回值：
	成功：文件指针
	失败：NULL
*/
FILE * fp=fopen("./1.txt","w+");
close(fp);

```

| 打开模式 | 含义                                                                              |
| -------- | --------------------------------------------------------------------------------- |
| r或rb    | 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错）                      |
| w或wb    | 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)                |
| a或ab    | 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件                        |
| r+或rb+  | 以可读、可写的方式打开文件(不创建新文件),如果文件存在，就覆盖文件（注意不是清空） |
| w+或wb+  | 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)      |
| a+或ab+  | 以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件               |


### 特殊的文件指针
C语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用:  
1. stdin： 标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据。
1. stdout：标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端。
1. stderr：标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端。
### 文件的读写

#### 读写字符串 - fputs/fputc/fgets/fgetc
```c
//函数原型 行写入和字符写入
int fputs(const char * str, FILE * stream);
int fputc(int c, FILE *stream);
/*
功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\0'  不写入文件。
行读写更适合用于处理文本文件。
参数：
	str：字符串
	stream：文件指针
返回值：
	成功：0
	失败：-1
*/
//函数原型 行读取和字符读取
char * fgets(char * str, int size, FILE * stream);
int fgetc(FILE *stream);
/*
功能：从stream指定的文件内读入字符串，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束。
参数：
	str：字符串
	size：指定最大读取字符串的长度（size - 1）
	stream：文件指针
返回值：
	成功：成功读取的字符串
	读到文件尾或出错： NULL
*/
```
#### 读写字符串 - fwrite/fread
```c
//函数原型
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
/*
功能：以数据块的方式给文件写入内容。块读写更适合用于处理二进制文件。按照字节来读
参数：
	ptr：准备写入文件数据的地址，要写入文件的缓冲区的首地址。
	size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小
	nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb
	stream：已经打开的文件指针
返回值：
	成功：实际成功写入文件数据的块数目，此值和 nmemb 相等
	失败：0
*/

//函数原型
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
/*
功能：以数据块的方式从文件中读取内容
参数：
	ptr：存放读取出来数据的内存空间
	size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小
	nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb
	stream：已经打开的文件指针    
返回值：
	成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。
	失败：0
*/

```
#### 读写字符串 - fprintf/fscanf
```c
int fprintf(FILE * stream, const char * format, ...);
/*
功能：遇到格式化写入文件时，应该想到这个函数。根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\0'  为止。
参数：
	stream：已经打开的文件
	format：字符串格式，用法和printf()一样
返回值：
	成功：实际写入文件的字符个数
	失败：-1
*/
int fscanf(FILE * stream, const char * format, ...);
/*
功能：遇到格式化读取文件时，应该想到这个函数。
从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。
参数：
	stream：已经打开的文件
	format：字符串格式，用法和scanf()一样
返回值：
	成功：参数数目，成功转换的值的个数
	失败： - 1
*/

```
### 文件的随机读写,文件指针改变位置
```c
int fseek(FILE *stream, long offset, int whence);
/*
功能：移动文件流（文件光标）的读写位置。
参数：
	stream：已经打开的文件指针
	offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。
whence：其取值如下：
    SEEK_SET：从文件开头移动offset个字节
    SEEK_CUR：从当前位置移动offset个字节
    SEEK_END：从文件末尾移动offset个字节
返回值：
	成功：0
	失败：-1
还能扩充文件,向文件尾偏移,但是要写个字符
*/

long ftell(FILE *stream);
/*
功能：获取文件流（文件光标）的读写位置。
参数：
	stream：已经打开的文件指针
返回值：
	成功：当前文件流（文件光标）的读写位置
	失败：-1
*/

void rewind(FILE *stream);
/*
功能：把文件流（文件光标）的读写位置移动到文件开头。
参数：
	stream：已经打开的文件指针
返回值：
	无返回值
*/
```
### 删除/重命名文件
```c
int remove(const char *pathname);
/*
功能：删除文件
参数：
	pathname：文件名
返回值：
	成功：0
	失败：-1
可以自己删除自己
*/

int rename(const char *oldpath, const char *newpath);
/*
功能：把oldpath的文件名改为newpath
参数：
    oldpath：旧文件名
    newpath：新文件名
返回值：
    成功：0
    失败： - 1
也可以将一个文件改到另外一个目录下
*/
```
### 文件的关闭
```c
//函数原型
int fclose(FILE * stream);
功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。
参数：
	stream：文件指针
返回值：
	成功：0
	失败：-1
```
### 更新缓冲区
```c
int fflush(FILE *stream);
/*
功能：更新缓冲区，让缓冲区的数据立马写到文件中。
参数：
    stream：文件指针
返回值：
    成功：0
    失败：-1
*/
```
## 文件状态
```c
#include <sys/types.h>
#include <sys/stat.h>
int stat(const char *path, struct stat *buf);
/*
功能：获取文件状态信息
参数：
    path：文件名
    buf：保存文件信息的结构体
返回值：
    成功：0
    失败-1
【注意】：从函数获取值有两种方法：
    1、通过函数的返回值获取函数返回的值。
    2、通过把变量的地址传给函数，函数拿到变量的地址之后，再函数内部修改变量的值，从而实现修改主调函数中变量的效果。
*/
//如果是链接文件的时候,stat()会穿透链接文件,但是使用lstat(),传什么文件,就返回什么文件的属性
int lstat(const char *path, struct stat *buf);

//结构体内容
struct stat {
	dev_t         st_dev;         //文件的设备编号
	ino_t         st_ino;          //节点
	mode_t        st_mode;  	 //文件的类型和存取的权限
	nlink_t       st_nlink;     	//连到该文件的硬连接数目，刚建立的文件值为1
	uid_t         st_uid;         //用户ID
	gid_t         st_gid;         //组ID
	dev_t         st_rdev;      	//(设备类型)若此文件为设备文件，则为其设备编号
	off_t         st_size;        	//文件字节数(文件大小)
	unsigned long st_blksize;   	//块大小(文件系统的I/O 缓冲区大小)
	unsigned long st_blocks;    	//块数
	time_t        st_atime;     	//最后一次访问时间
	time_t        st_mtime;    	//最后一次修改时间
	time_t        st_ctime;     	//最后一次改变时间(指属性)
};
```
`time_t`结构体转换为`struct tm`结构体
```c

struct tm *localtime(const time_t *timep);
/*
    timer -- 这是指向表示日历时间的 time_t 值的指针
返回值是下面的一个结构体
*/
/*

struct tm {
        int tm_sec;    // Seconds (0-60) 
        int tm_min;    // Minutes (0-59) 
        int tm_hour;   // Hours (0-23) 
        int tm_mday;   // Day of the month (1-31) 
        int tm_mon;    // Month (0-11) 
        int tm_year;   // Year - 1900 
        int tm_wday;   // Day of the week (0-6, Sunday = 0) 
        int tm_yday;   // Day in the year (0-365, 1 Jan = 0) 
        int tm_isdst;  // Daylight saving time 
    };
*/
```
获取文件最后一次修改时间
```c
#include <stdio.h>
#include <sys/stat.h>
#include <time.h>
int main(int argc , char** argv,char** envp)
{
    struct stat s;
    stat("1.txt",&s);
    printf("最后一次修改时间为%lu\n",s.st_mtime);
    struct tm *t=localtime(&s.st_mtime);
    printf("最后一次修改时间为%d年%d月%d日%d:%d:%d\n",t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);
    return 0;
}
```
### 文件重命名
```c

#include <stdio.h>

int rename(const char *oldpath, const char *newpath);

#include <fcntl.h>           /* Definition of AT_* constants */
#include <stdio.h>

int renameat(int olddirfd, const char *oldpath,int newdirfd, const char *newpath);
int renameat2(int olddirfd, const char *oldpath,int newdirfd, const char *newpath, unsigned int flags);

返回值
    成功返回0
    失败返回-1
```

## 输出彩色字符
在代码量较大时，希望可以看见更直观的调试信息，那么把输出设置成不同颜色不失为一种优秀的做法~

printf 彩色输出需要用到控制命令：`\033[A1;A2;A3m`

控制命令以`\033[`开头，以 ` m ` 结尾，而中间则是属性码，属性代码之间使用`;`分隔，如`\033[1;34;40m`。

`A1;A2;A3` 支持右侧省略原则，即只有两个参数时，默认为`A1;A2` ,只有一个参数时，默认为`A1`。

    A1：属性；
    A2：前景色；(字体颜色)
    A3：背景色；(填充颜色)

### 属性代码(A1)：

| 属性代码 | 功能         |
| -------- | ------------ |
| 0        | 重置所有属性 |
| 1        | 高亮/加粗    |
| 2        | 暗淡         |
| 4        | 下划线       |
| 5        | 闪烁         |
| 7        | 反转         |
| 8        | 隐藏         |
### 前景色（A2）：

| 属性代码 | 功能 |
| -------- | ---- |
| 30       | 黑色 |
| 31       | 红色 |
| 32       | 绿色 |
| 33       | 黄色 |
| 34       | 蓝色 |
| 35       | 品红 |
| 36       | 青色 |
### 背景色（A3）：

| 属性代码 | 功能 |
| -------- | ---- |
| 40       | 黑色 |
| 41       | 红色 |
| 42       | 绿色 |
| 43       | 黄色 |
| 44       | 蓝色 |
| 45       | 品红 |
| 46       | 青色 |
示例：

红色内容 
```c
printf("\033[0m\033[1;31m%s\033[0m", "Hello World!");
/*
    \033[0m ： 重置所有属性
    \033[1;31m ：设置前景色为红色
    %s ： 字符串的格式控制符
    \033[0m ： 重置所有属性
*/
```

## 进程的函数接口
单进程程序  -> 只能一行行代码去执行。  
多进程程序  -> 同时执行两行代码  -> 产生一个子进程，帮自己处理另外一件事情。
### 产生子进程-`fork()`

```c
#include <unistd.h>
pid_t fork(void);
/* 
作用
    创建一个进程，将父进程的资源复制一份，申请一片新的资源给子进程，他们的资源都是独立的
    并且从fork创建处开始运行 相对应数据一模一样
返回值
    成功： （一次调用，两次返回）
        >0       父进程            但是返回的ID号表示的是子进程的ID号
        =0       子进程
    失败
        返回  -15

    fork出错可能有两种原因：
    1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
    2）系统内存不足，这时errno的值被设置为ENOMEM。
 */
```
### 产生子进程的另一个函数vfork

```c
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void);
/* 
函数作用：创建一个子进程。子进程共享父进程的地址空间
（准确来说，在调用exec(进程替换)或exit(退出进程)之前与父进程数据是共享的）
特点：
    1.子进程共享父进程的地址空间
    2.一定是子进程先运行，而且等子进程结束之后，父进程才开始运行
    3.当子进程调用exit之后，父进程才会往下执行
    4.你在引用的时候，最好尽快结束子进程
    5.用vfork函数创建进程，子进程里一定要调用exec(进程替换)或者exit(退出进程)，会造成文件死锁，是有问题的程序，没有意义
 */
```

### 在一个进程中查看自己的PID号以及父进程的PID号
```c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
pid_t getppid(void);
/* 
返回值
    成功
        getpid---->返回自己的ID号
        getppid--->返回父进程的ID号
    失败
        不会失败
 */
```
### 等待进程退出
```c
#include <sys/types.h>
#include <sys/wait.h>
//等待一个进程为的就是帮这个进程修改状态 (从僵尸态变成死亡态)  
pid_t wait(int *status);
/* 
参数：
    status：    监听子进程的退出状态
    填NULL，例如： wait(NULL)        -> 代表父进程只回收资源，但是不关心子进程的退出状态。
    不填NULL，例如： int x; wait(&x);-> 代表父进程不仅回收资源，还关心子进程的退出状态，退出状态会保存到x变量中。

    返回值：
        成功：回收资源的那个子进程的ID号
        失败：-1
 */
```
注意：  
wait属于一个阻塞函数，如果子进程没有退出变成僵尸态，那么这个函数就会阻塞，直到子进程变成僵尸态之后，才会将子进程的资源回收。status还可以保存子进程的退出状态。

### 进程的退出
大概分为这几种方式  
`exit()` /`_Exit()` / `_exit()`/`return 0(main函数中)`
#### exit()
功能： cause normal process termination  
//导致一个进程的结束。
```c
#include <stdlib.h>
void exit(int status);
/* 
函数作用
先清洗缓冲区，再退出
exit 函数设置的退出值  只能是 0~255 范围
参数：
    status： 退出状态值
    0  -> 进程正常退出
    非0 -> 进程异常退出
 */
```
#### _Exit() / _exit()
`_Exit()` / `_exit()` --------不会清洗缓冲区，直接退出

功能： terminate the calling process
```c
//结束一个正在运行的进程
#include <unistd.h>
void _exit(int status);
#include <stdlib.h>
void _Exit(int status);
/* 
参数：
    status： 退出状态值
    0  -> 进程正常退出
    非0 -> 进程异常退出
 */
```

## exec函数簇 
-  问题引入：  
我们在创建出子进程之后，希望子进程执行其他任务。  
一般情况下，可以将子进程的任务封装成接口，在子进程中调用，对于简单任务可以这么做，但是对于一些复杂任务，这样做维护起来就很麻烦，还有有些任务可能是脚本语言写的，存在语言兼容问题，  

比如客户端游戏程序去刷副本任务，副本任务是使用脚本文件去写的，所以创建一个子进程，有没有办法，让我们的子进程直接执行脚本任务。此时就可以借助exec函数簇。

在Unix及Unix类操作系统中，exec 函数族（即 `execl()`, `execle()`, `execlp()`, `execv()`, `execvp()` 等函数）被广泛用于让一个进程执行另一个可执行程序文件。  
当一个进程调用 `exec()` 函数时，该进程的全部内容都会被新程序替换，而新程序从 main() 函数开始执行。

这个过程发生的一瞬间，原进程几乎无法保存自己的状态（例如内存中分配的变量和动态连接库）。因此，exec 被认为是一种创建新进程的机制而不是重新启动现有进程的机制。

```c
//功能：在进程中加载新的程序或者脚本，覆盖原有的代码，重新运行
#include <unistd.h>


extern char **environ;

int execl(const char *path, const char *arg, ...
                /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
                /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
char *const envp[]);
/* 
参数：
    path
        即将被加载执行的ELF文件或者脚本的路径
    file
        即将被加载执行的ELF文件或者脚本的名字
    arg
        以列表的形式罗列的ELF文件或者脚本的参数
    argv
        以数组的方式组织的ELF文件或者脚本的参数
    envp
        用户自定义的环境变量数组
返回值：
    成功 不返回  失败 -1

备注：
    1.函数名字带字母 l 意味着其参数以列表（list）的方式提供
    2.函数名字带字母 v 意味着其参数以矢量（vetor）数组的方式提供
    3.函数名字带字母 p 意味着其会利用环境变量PATH来寻找指定的执行文件
    4.函数名字带字母 e 意味着用户提供自定义的环境变量
 */
```

    第一种方法：
    execl("./process","./process","abc",NULL);
    第二种方法：
    execlp("ls","ls","-l",NULL);//函数名字带字母p意味着其会利用环境变量PATH来寻找指定的执行文件
    第三种方法：
    char *const argv[]={"./process","abc",NULL};
    execv("./process",argv);
    第四种写法：
    char *const argv[]={"ls","-l",NULL};
    execvp("ls",argv);
    第五种写法：
    char *const argv[]={"process","abc",NULL};
    char *const envp[]={"./"};//exevpe不仅仅会去PATH环境变量中寻找程序，还会去指定的envp下寻找
    execvpe("process",argv);//函数名字带字母e意味着用户提供自定义的环境变量
## 管道
### 无名管道
什么是无名管道？作用机制如何？
无名管道只能作用于亲缘关系的进行之间的通信，例如父子进程。无名管道是没有名字的管道文件，相当于一个队列结构，fd[1]为写入端（入队）
fd[0]读取端（出队）。其中信息读出过后即删除，下一次读取就是下一个信息
```c
#include <unistd.h>

int pipe(int pipefd[2]);
/* 
参数：
    pipefd
        包含了两个元素的整型数组
函数返回值：成功返回0，失败：-1
 */
```
### 有名管道
什么是有名管道，机制如何？
有名管道就是一个有名字的管道文件。在linux下，所有进程都是可以可以看到这个文件，所有他的作用范围整个linux系统
2、如何创建有名管道文件？--->mkfifo--->man 3 mkfifocanh
jack与rose的七夕通信：（有名管道）

```c
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
/* 
参数:
    pathname
        有名管道文件的路径+管道名  例如：/tmp/myfifo
    mode
        管道文件权限 0777满权限
返回值：
    成功 0
    失败返回 -1
 */    
```

## 信号函数的接口
### 发送信号
```c
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
/* 
函数作用：向指定的进程或者进程组，发送一个指定的信号
参数：
    pid
        <-1    信号将被发送给组ID等于-pid的进程组里面的所有进程
        -1    信号将被发送给所有进程(如果该进程对其有权限)
        0    信号将被发送给与当前进程同一个进程组内的所有进程
        >0    信号将被发送给PID等于pid的指定进程
    sig
        要发送的信号
 */
```


### 捕捉信号
```c
#include <signal.h>

void (*signal (int sig ,void (*func)(int))) (int) ;
// 可以表达为
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
/* 
函数作用：捕捉一个指定的信号，即预先为某一个到来做好准备                                                       
参数：
    signum
        需要捕捉的信号
    handler
        SIG_IGN ----->忽略该信号
        SIG_DFL-------default--->执行该信号的默认动作
    void（*p）(int)
        执行由p指向的信号 
    func
        响应函数
返回值：
    成功返回 最近一次调用该函数时第二个参数的值
    失败返回： SIG_ERR（#define SIG_ERR -1）

注意：
1.所谓的捕捉信号就是获取当这个信号来之后，去执行信号响应函数，原本的信号默认动作就不会执行了
2.当调用signal函数之后，程序不会阻塞，而是往下面代码执行，这个捕捉设置是去全局有效的
3.SIGKILL,SIGSTOP不能被捕捉，只能执行默认动作
*/
```


### 挂起进程
```c
#include <unistd.h>

 int pause(void);
/* 
返回值：收到非致命信号或者已经被捕捉的信号 -1
       收到致命信号导致进程异常退出，不返回
 */
```
注意：pause()是在响应函数返回之后，再返回的、
### 给自己发信号
```c
#include <signal.h>
int raise(int sig);
/* 
参数：发送的信号
返回值：
    成功返回0
    失败返回非0
 */
```

### 信号的处理（除了SIGKILL，SIGSTOP）
1. 忽略(将信号丢弃)  
    `signal(signum,SIG_INT);`
2. 缺省(默认动作)  
    `signal(signum,SIG_DFL);`
3. 捕捉(去执行指定的动作)  
    `signal(signum,function);`
4. 阻塞(信号挂起)    
    设置阻塞之后，来了阻塞的指定信号，并不是将信号丢弃，而是将信号挂起，等到解除阻塞，才响应这个信号。

比如你正在接待客户，此时你的朋友（信号1）过来找你，正确的做法，让他等待，而不是让他滚（信号丢弃）。
如果有很多朋友（多个信号）来找你，那么需要将所有的信号设置成阻塞态，也就是如何管理多个信号，就要
用到，信号集操作。 

    注意：9) SIGKILL  和19) SIGSTOP ，这两个信号不能被忽略,捕捉和阻塞,必须执行默认动作

## 信号集处理函数
### 定义信号集
信号集是一个变量，数据类型是：`sigset_t`.
```c
//信号集结构体  - sigset_t
sigset_t set

#include <signal.h>
//清空信号集
int sigemptyset(sigset_t *set);
//将linux下所有的信号都加入到信号集中
int sigfillset(sigset_t *set);
//在信号集set中，添加一个指定的信号signum
int sigaddset(sigset_t *set, int signum);
//在信号集set中，删除一个指定的信号signum
int sigdelset(sigset_t *set, int signum);
//测试某一个信号在不在信号集中
int sigismember(const sigset_t *set, int signum);
/* 
参数：
    set
        需要判断的信号集的地址
    signum
        需要测试的信号
返回值：
    成功：0
    失败：-1
sigismember函数
    在集合中，返回1，不在集合中，返回0 失败返回-1
 */
```
### 设置信号集为阻塞状态
```c
#include <signal.h>
//将信号 设置/取消 阻塞状态
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
/* 
参数：
    how
        SIG_BLOCK---->设置为阻塞属性
        SIG_UNBLOCK---->设置为解除阻塞属性
    set
        设置哪一个信号集，将这个信号集的地址传来
    oldset
        保留之前的状态的指针，如果不关心，就写NULL
返回值：
       成功返回0
       失败返回-1
 */
// 例子：
sigprocmask(SIG_BLOCK,&set,NULL);      //--->设置为阻塞
sigprocmask(SIG_UNBLOCK,&set,NULL);    //--->解除阻塞
```

## linuxIPC对象
### 命令删除IPC对象
查看系统中所有的IPC对象
查看IPC对象,终端输入：`ipcs -a`  
想删除消息队列：`ipcrm -q 消息队列的key值` /    `ipcrm -q 消息队列的ID值`  
想删除共享内存：`ipcrm -m共享内存的key值` /    `ipcrm -m 共享内存的ID值`  
想删除信号量：`ipcrm -s 信号量的key值` /    `ipcrm -s 信号量的ID值`  

### 申请key值

```c
#include <sys/types.h>
#include <sys/ipc.h>

// 函数作用：获得一个key值
key_t ftok(const char *pathname, int proj_id);
/* 
参数：
    pathname
        一个合法的路径。常用"."
    proj_id
        非0整数。常用10
返回值：
    成功返回key值
    失败-1
 */
```

当文件路径和id是一样的时候，两个ftok函数的返回值-------key值是一样的

只要文件路径或者id有一个不一样，返回的key就是不一样的


### 消息队列
消息队列是IPC对象，一定要申请KEY值

#### 消息队列机制
进程1往消息队列中发信息："类型"+"数据正文" -> 类型->数据编号  
进程2收信息从消息队列里面去读，只需要提供相应的数据的编号就可以读取特定的数据了
#### 消息队列作用范围
消息队列作用范围 -> linux下任意两个进程
#### 消息队列的结构体函数
```c

// 自己定义的消息队列的数据结构体
struct msgbuf
{
    long type;        // 数据的编号(类型)
    char mtext[1024]; // 数据的正文
};
```
#### 消息队列的相关函数
##### 使用消息队列来通信
- 申请消息队列的key值  
    `key=ftok(".",10);`
- 根据消息队列的key值获取ID号,使用`msgget()`，如果该key值对应的消息不存在则会创建
```c 
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
//函数作用：得到消息队列的ID号（不存在消息队列就创建）
int msgget(key_t key, int msgflg);
/* 
参数：
    key
        消息队列的key值
    msgflag
        如果不存在则创建，并且给权限
        通常使用 IPC_CERAT|0666 
返回值：
     成功返回消息队列的ID号
     失败返回-1
 */
```
##### 往消息队列中写入数据
```c
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/msg.h>
// 函数作用：往消息队列中写入数据
 int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
/* 
参数:
    msqid
        消息队列的id号
    msgp
        你要写的数据,传递的是地址
    msgsz
        数据正文的大小 
        指的是char mtext[1024]中使用的大小而不是整个结构体或者数组大小
    msgflag
        一般属性,默认使用0
返回值：
    成功返回0
    失败返回-1
 */
```
##### 往消息队列中读取数据(接收数据)
```c
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/msg.h>
 
// 函数作用：往消息队列中写入数据
 ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
int msgflg);
/* 
参数:
    msqid
        消息队列的id号
    msgp
        你要写的数据,传递的是地址
    msgsz
        数据正文的大小 
        指的是char mtext[1024]中使用的大小而不是整个结构体或者数组大小
    msgtyp
        读取的数据的类型或者说编号
    msgflag
        一般属性,默认使用0
返回值：
    成功返回读取到的字节数
    失败返回-1
 */

```
##### 删除消息队列
```c
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/msg.h>

 int msgctl(int msqid, int cmd, struct msqid_ds *buf);
/* 
参数:
    msqid
        消息队列的id号
    cmd - 需要操作的命令
        IPC_STAT ->获取消息队列的状态,那么最后一个参数就要写
        IPC_RMID ->删除消息队列,第三个参数就要填NULL
    buf
        数据存储的结构体
 */
// 例子：
msgctl(msgid,IPC_RMID,NULL);

```     
### 共享内存
对于消息队列和有名管道来讲,使用的时候需要1经过内核的调度,  
所以说共享内存 是比消息队列和有名管道访问还快.

#### 申请共享内存ID号
```c
#include <sys/ipc.h>
#include <sys/shm.h>

int shmget(key_t key, size_t size, int shmflg);
/* 
---->share memory get
参数
    key值
    size
        共享内存总字节数,必须是PAGE_SIZE(1024)的整数倍
         #define PAGE_SIZE 1024
    shmdlag    
        常使用IPC_CREAT|0666
返回值：
    成功返回：共享内存的ID号
    失败：-1
 */
```
#### 将共享内存映射到本地虚拟内存
```c
// 根据ID号将共享内存的映射至本进程虚拟机内存空间的某一个区域
 #include <sys/types.h>
 #include <sys/shm.h>

 void *shmat(int shmid, const void *shmaddr, int shmflg);
/* 
参数
    shmid
        共享内存的ID
    shmaddr
        共享内存的起始地址 填NULL -> 系统自动分配
    shmflg
        普通属性 填0
返回值：
    成功：共享内存的的起始地址
    失败：（void *）-1 
 */    
         
// 当不在使用时，解除映射    
int shmdt(const void *shmaddr);
/* 
参数：
    shmadd
        你需要解除内存映射的地址
返回值：
    成功返回0
    失败返回-1   
 */
```
#### 删除共享内存
```c
//当没有进程再需要使用这块共享内存，删除它-->shmctl--->man 2 shmctl
#include <sys/ipc.h>
#include <sys/shm.h>

int shmctl(int shmid, int cmd, struct shmid_ds *buf);
/* 
参数
    shmid
        共享内存的ID
    cmd 一些操作命令
        IPC_STAT(获取属性的信息)，必须填第3个参数
        IPC_RMID（删除共享内存）--->第3个参数填NULL
    buf
        根据第二个参数判断是否填
返回值：
    成功返回0
    失败返回-1
 */
```
### 信号量函数的接口
#### 根据key值申请id值
```c
//根据key值申请信号量ID号
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semget(key_t key, int nsems, int semflg);
/* 
参数
    key
        信号量的key值
    nsems
        信号量元素的个数。例如：空间+数据->2
    semflg
        IPC_CREAT|0666--->不存在就创建
返回值：
    成功返回信号量的ID
    失败返回-1
 */
```
#### 控制信号量的参数
```c
// 控制信号量值参数
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semctl(int semid, int semnum, int cmd, ...);
/* 
参数
    semid
        信号量的ID
    semnum
        需要操作的成员的下标 空间0 数据1
    cmd
        SETVAL ---->用于设置信号量的起始值
        IPC_RMID---->删除信号量的ID
    参数4
        空间/数据的起始值
返回值：
    成功返回0
    失败返回-1
 */

// 例子：想设置空间起始值1，数据的起始值为0
semctl(semid,0,SETVAL,1);
semctl(semid,1,SETVAL,0);

// 删除两个信号量
semctl(semid,0,IPC_RMID);
semctl(semid,1,IPC_RMID);
```
#### 信号量的pv操作
```c
// 如何实现信号量的P/V操作？（P操作1->0 V操作0->1）
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semop(int semid, struct sembuf *sops, size_t nsops);
/* 
参数
    semid
        信号量的ID号
    sops
        进程PV操作的结构体
    nsops
        信号量结构体的个数---->1
返回值：
   成功返回0
   失败返回-1
 */
```
#### 信号量的操作结构体
```c

//   信号量操作结构体的定义如下：
struct sembuf
{
    unsigned short sem_num; /* 信号量元素序号（数组下标）如: 空间0 数据1*/
    short sem_op; /* 操作参数 -----PV操作 加或减操作*/
    short sem_flg; /* 操作选项 ----->普通属性，填0*/
};
/* 
  请注意：信号量元素的序号从 0 开始，实际上就是数组下标
  根据 sem_op 的数值，信号量操作分成 3 种情况：
  A) 当 sem_op 大于 0 时：进行 V 操作，即信号量元素的值（semval）将会被加上sem_op 的值。
  C) 当 sem_op 小于 0 时：进行 P 操作，即信号量元素的值（semval）将会被减去sem_op 的绝对值。
 */
```
## 关于进程组的函数
### 设置/获取进程所属的进程组
```c
#include <sys/types.h>
#include <unistd.h>

// 功能：将进程pid的所在进程组设置为pgid
//       如果pid == 0，则设置本进程
//       如果pgid == 0，等价于pgid == pid
// 注意：若进程pid与进程组pgid不在同一会话内，设置将失败
int setpgid(pid_t pid, pid_t pgid);
返回值：成功0
       失败-1
// 功能：获取进程pid所在进程组ID
pid_t getpgid(pid_t pid);

 On success, setpgid() and setpgrp() return zero.  On error, -1 is returned
```
例子
```c
// 将指定进程123加入进程组7799中
// 注意，进程组7799必须存在且与进程123同处相同的会话
setpgid(123, 7799);

// 将本进程加入进程组7799中
// 注意，进程组7799必须存在且与本进程同处相同的会话
setpgid(0, 7799);

// 创建一个ID等于本进程PID的进程组
// 并将本进程置入其中，成为进程组组长
setpgid(0, 0);
```
### 创建新会话
```c
// 当我们打开一个伪终端，或者打开一个远程登录工具输入账户密码的过程中，默认都调用了如下函数接口去创建一个新的会话。
#include <sys/types.h>
#include <unistd.h>

pid_t setsid(void);
```
注意：
- 进程组组长不能调用该函数。
- 新创建的会话没有关联控制终端，因此其内进程不受控制终端影响。
- 创建会话的进程，称为该会话的创始进程，创始进程有权捕获一个控制终端（在编写守护进程时通常需要避免），会话的其余成员进程无权获得控制终端。

例子  
脱离控制终端,避免再次获取控制终端等操作
```c
// 忽略信号SIGHUP
signal(SIGHUP, SIG_IGN);

// 脱离控制终端（新建一个会话）
setsid();

// 避免会话再次关联控制终端（退出会话创始进程）
if(fork() > 0)
    exit(0);
```
## 关于工作路径

任何一个进程都有一个当前工作路径，从终端启动的进程的工作路径就是启动时终端所在的系统路径。以下代码可以输出进程当前所在路径
```c
int main(void)
{
    printf("%s\n", getcwd(NULL, 0));
}
```
当一个进程的工作路径被卸载时，进程也会随时消亡。守护进程为了避免此种情况发生，最简单的做法就是将自身的工作路径切换到一个无法被卸载的路径下，比如根目录。
实现代码如下：
```c
// 8，避免所在路径被卸载
chdir("/");
```

## 线程函数

### 线程的创建和回收
```c
 #include <pthread.h>

 int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start_routine) (void *), void *arg);
/* 
参数
    thread
        存储线程ID号的变量的地址
    attr
        attribute属性,普通属性填NULL
    start_routine
        线程执行的函数 函数是 void*返回值,void*作为参数
    arg
        传递给子线程的参数
返回值：
    成功：返回0    
    失败：非0错误码
 */
/* 
 注意：
 （1）只要你的程序涉及到线程，就必须编译的时候链接库             
 Compile and link with -pthread.//编译链接需要-pthread库
 （2）如果ubuntu找不到man手册线程库的接口，需要安装
 sudo apt-get install manpages-posix-dev
 */
```

主线程和其他线程的关闭情况

- 情况1：主线程的时间>子线程的工作时间  
    主线程会与子线程一起运行，子线程工作完毕，主线程继续工作，然后就执行return 0，进程退出
- 情况2：主线程的时间<子线程的工作时间  
    主线程工作完毕，执行return 0导致了进程的退出，进程退出就会导致进程内部的所有的线程都退出 
### 阻塞线程直到线程退出 得到线程的值
```c
 #include <pthread.h>

int pthread_join(pthread_t thread, void **retval);
/* 
 函数作用：阻塞等待子线程的退出,回收资源
参数
    thread
        需要接合的线程ID号
    retval
        存储子线程的退出值指针，如果填NULL,代表不关心子线程的退出状态
返回值：
    成功0
    失败：非0                         
 */
```
 
验证主线程与子线程工作时间长短问题，结果是怎样？  
- 情况1：主线程的工作时间长，去接合----->  pthread_join()会立马返回  
- 情况2：主线程的工作时间短，去接合----->  pthread_join()会阻塞等待子线程的退出。   
### 线程的主动退出
```c
#include <pthread.h>

void pthread_exit(void *retval);
/* 
函数作用：子线程主动结束退出
参数：
    retval 
        子线程退出值变量的地址->这个退出值必须是全局变量
 */
```
### 获取线程的id号
```c
#include <pthread.h>

pthread_t pthread_self(void);
/* 
返回值：线程的ID号
 */
```
### 主动发送取消请求给一个线程
```c
#include <pthread.h>

//  函数作用：发送一个取消请求给子线程
int pthread_cancel(pthread_t thread);
/* 
参数：
    pthread
        需要取消的线程的ID号
返回值：
    成功0
    失败：非0错误码
 */
```

注意
    使用`pthread_exit()`函数退出是退出值,且退出值可以由`pthread_join()`获得线程退出值
    使用`pthread_cancel()`取消线程没有退出值
### 设置线程响应取消状态
```c
#include <pthread.h>

int pthread_setcancelstate(int state, int *oldstate);
/* 
参数
    state
        PTHREAD_CANCEL_ENABLE--->能响应（线程的默认属性）
        PTHREAD_CANCEL_DISABLE--->不能响应
    oldstate    
        保留之前的状态，如果不关心，填NULL
返回值：
    成功0
    失败：非0错误码                               
 */

```
1、如果一个线程不能响应取消，那么在这个过程中收到取消请求，直到这个线程能响应取消为止，收到取消信号才会被响应  
2、如果该线程收到取消请求，没法响应，那么会阻塞直到这个线程能响应为止
### 设置线程响应取消类型
```c
int pthread_setcanceltype(int type, int *oldtype);
/* 
参数
    type
        PTHREAD_CANCEL_DEFERRED-->延迟响应--->遇到一个取消函数才会响应取消请求-->线程默认属性
    oldtype
        保留之前的状态，如果不关心，填NULL
返回值：
    成功0
    失败：非0错误码  
*/
// 注意：线程是遇到取消点函数之后才会去响应取消
// 取消函数有哪些？--->man 7 pthreads
fprintf()
fputc()
fputs()
sleep()
printf()
usleep() 
```

## 线程分离属性
什么是分离属性

    首先分离属性是线程的一个属性，有了分离属性的线程，不需要别的线程去接合它（自己回收资源）
    但是虽说是分离的，但是进程结束了，该线程还是会退出
    设置了分离属性----->不需要pthread_join()
    设置了非分离属性----->需要pthread_join()--->默认创建的普通线程是非分离属性线程

如何创建分离属性的线程
- 方法1：  
    添加一个分离属性到一个属性变量中，然后使用属性变量去创建一个线程，那么创建出来的线程就是具有分离属性的线程
- 方法二:  
    先创建一个普通线程，然后在线程中调用一个设置分离属性的函数，那么该线程就变成了有分离属性的线程

当一个分离属性的线程退出，主线程还可不可以去接合它？  
    不可以  

一个分离属性的线程，在进程退出时，该分离属性的线程还会不会继续运行？  
    不会
### 线程分离属性的结构体
```c
pthread_attr_t attr;
```
### 去初始化属性变量
```c
#include <pthread.h>

int pthread_attr_init(pthread_attr_t *attr);
/* 
参数
    attr
        未初始化的属性变量
返回值：
    成功返回0
    失败非0错误码
 */
```
### 将分离属性添加到属性变量中
```c
#include <pthread.h>

int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
/* 
参数
    attr
        已经初始化过的属性变量
    detachstate 属性
        PTHREAD_CREATE_DETACHED   分离属性          
        PTHREAD_CREATE_JOINABLE   非分离属性    
返回值：
    成功返回0
    失败非0错误码
 */
```
### 销毁属性变量
```c
 int pthread_attr_destroy(pthread_attr_t *attr);
/* 
参数：
    attr
        已经初始化的属性变量
返回值：
    成功返回0
    失败非0错误码
 */
```
### 创建线程后设置为分离属性
```c
 #include <pthread.h>

// 函数作用：设置分离属性到线程
 int pthread_detach(pthread_t thread);
/* 
参数：
    thread
        需要设置分离属性的线程的ID号
返回值：
    成功返回0
    失败非0错误码
 */
```

### 有名信号量函数
#### 创建有名信号量
```c
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */
#include <semaphore.h>

// 函数作用：初始化并且打开一个有名信号量
sem_t *sem_open(const char *name, int oflag);
sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);
/* 
参数
    name
        有名信号量的名称,必须是"/"开头,如:"/sem" -> 存在于/dev/shm目录下
    oflag
        O_CREAT 不存在就创建
        O_CREAT|O_EXCL  不存在就创建，存在就报错    
    mode
        八进制权限，例如：0777
    value
        有名信号量的起始值
返回值：
    成功返回：有名信号量的地址
    失败返回：SEM_FAILED--->NULL/(sem_t *)-1                         

当 oflag 中有 O_CREAT 这个选项,那么后面两个参数必须要填
当有名信号量已经存在了,但是又写了O_CREAT,那么后面两个参数就会被忽略
 */
```
#### 有名信号量的P操作
```c
#include <semaphore.h>

int sem_wait(sem_t *sem);//如果减不了1，这个函数就会阻塞
/* 
参数
    sem -> 有名信号量的地址
返回值：
    成功返回0----->资源可以减1
    失败：-1
*/

// 例子：
/* 
如果当前值2，那么sem_wait()马上返回，并且将值设置为1
如果当前值1，那么sem_wait()马上返回，并且将值设置为0
如果当前值0，那么sem_wait()就会阻塞，一直阻塞到有名信号量的值不为0为止。
 */
```
#### 有名信号量的V操作
```c
#include <semaphore.h>

int sem_post(sem_t *sem);//一定可以加1，绝对不会阻塞
/* 
参数
    sem -> 有名信号量的地址
返回值：
    成功返回0----->资源可以加1
    失败：-1
*/
```
#### 关闭有名信号量
```c
#include <semaphore.h>

int sem_close(sem_t *sem);
/* 
参数
    sem -> 有名信号量的地址
返回值：
    成功返回0
    失败：-1
*/
```
#### 删除有名信号量
```c
#include <semaphore.h>

int sem_unlink(const char *name);

/* 
参数
    sem -> 有名信号量的名字
返回值：
    成功返回0
    失败：-1
*/
```

## 同步互斥之无名信号量
无名信号量通常用于线程之间的同步和互斥操作，因为它们更轻量且只存在于进程内部

无名信号量一般用于线程之间的互斥  
由于是无名信号量,所以说是没有名字的,不能用`sem_open`打开

### 无名信号量的函数
#### 无名信号量的创建
```c
sem_t sem;//无名信号不是一个文件，而是一个变量
```
#### 无名信号量的初始化
```c
#include <semaphore.h>

int sem_init(sem_t *sem, int pshared, unsigned int value);
/* 
参数
    sem
        无名信号量的地址
    pshared
        0 作用于线程之间(一把只考虑这种情况)
        非0 作用于进程之间
    value
        有名信号量的起始值
返回值：
    成功返回：0
    失败返回：-1
 */                               
```
#### 无名信号量的P操作
```c
#include <semaphore.h>

int sem_wait(sem_t *sem);//如果减不了1，这个函数就会阻塞
/* 
参数
    sem -> 无名信号量的地址
返回值：
    成功返回0----->资源可以减1
    失败：-1
*/

// 例子：
/* 
如果当前值2，那么sem_wait()马上返回，并且将值设置为1
如果当前值1，那么sem_wait()马上返回，并且将值设置为0
如果当前值0，那么sem_wait()就会阻塞，一直阻塞到无名信号量的值不为0为止。
 */
```
#### 无名信号量的V操作
```c
#include <semaphore.h>

int sem_post(sem_t *sem);//一定可以加1，绝对不会阻塞
/* 
参数
    sem -> 无名信号量的地址
返回值：
    成功返回0----->资源可以加1
    失败：-1
*/
```
#### 销毁无名信号量
```c
#include <semaphore.h>

int sem_destroy(sem_t *sem);
/* 
参数
    sem -> 无名信号量的地址
返回值：
    成功返回0
    失败：-1
*/
```

## 互斥锁的相关函数

### 定义互斥锁/创建互斥锁变量
```c
pthread_mutex_t m;
// pthread_mutex_t类型，其本质是一个结构体。简化理解，可忽略其实现的细节，简单看成整数
```
### 初始化互斥锁
```c
#include<pthread.h>
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
/* 
参数
    mutex
        未初始化的互斥锁变量的地址
    mutexattr
        普通属性,填NULL
返回值：
    成功返回0
    失败返回非0错误码
 */
 ```
例如
```c
// 静态初始化：
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
//  等价于:
pthread_mutex_t m;  
pthread_mutex_init(&m,NULL);
```
### 上锁互斥锁

```c
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);//尝试上锁
/* 
参数
    mutex - 的互斥锁变量的地址
返回值：
    成功返回0
    失败返回非0错误码
 */
```
### 解锁互斥锁

```c
int pthread_mutex_unlock(pthread_mutex_t *mutex);
/* 
参数
    mutex - 的互斥锁变量的地址
返回值：
    成功返回0
    失败返回非0错误码
 */
```

### 销毁互斥锁

```c
int pthread_mutex_destroy(pthread_mutex_t *mutex);
/* 
参数
    mutex - 的互斥锁变量的地址
返回值：
    成功返回0
    失败返回非0错误码
 */
```

## 读写锁的相关函数

### 定义读写变量
```c
pthread_rwlock_t rwlock;
```

### 初始化读写锁

```c
#include <pthread.h>

// 锁的初始化
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
const pthread_rwlockattr_t *restrict attr);
// 锁的解锁
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
/* 
参数
    rwlock      读写锁变量的地址
    attr      属性，一般为NULL
返回值：
    成功0
    失败：非0错误码        
 */
```
### 读锁上锁
```c
#include <pthread.h>

int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
/* 
参数
    rwlock      读写锁变量的地址
返回值：
    成功0
    失败：非0错误码        
 */
```
### 写锁上锁
```c
#include <pthread.h>

int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
/* 
参数
    rwlock      读写锁变量的地址
返回值：
    成功0
    失败：非0错误码        
 */
```
### 读写锁解锁
```c
#include <pthread.h>

int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
/* 
参数
    rwlock      读写锁变量的地址
返回值：
    成功0
    失败：非0错误码        
 */
```

## 条件变量

线程因为某一个条件/情况不成立的下，进入一个变量中等待，这个存放线程的变量就是条件变量。  
条件变量本身不是锁,但它可以造成线程堵塞。通常是与互斥锁配合使用。给多线程提供一个会合的场所

## 条件变量的函数
### 条件变量的定义
```c
pthread_cond_t  cond;
```
### 条件变量的初始化
```c
 #include <pthread.h>

int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);
/* 
参数
    cond
        条件变量的地址
    cond_attr
        普通属性，NULL
返回值：
    成功返回0
    失败返回非0错误码
 */
```

### 在条件变量中等待

```c
#include <pthread.h>

   
//阻塞等待一个条件变量
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

 //限时等待一个条件变量
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);

/* 
参数
    cond
        条件变量的地址
    mutex
        互斥锁的地址-->进入条件变量会自动解锁
    abstime
        绝对时间 绝对于1970年1月1日00：00：01秒(早已经过去)
返回值：
    成功返回0
    失败返回非0错误码
 */
```
关于`const struct timespec`
```c
struct timespec
{
    time_t tv_sec;/*second*/  //秒
    long tv_nsec;/*nanosecondes*/ //纳秒
}

// 形参：abstime--->绝对时间
// 如：time(NULL)返回的就是绝对时间，而alarm(1)是相对时间，相对当前是定时1秒

struct timespec t={1,0};
pthread_cond_timedwait(&cond,&mutex,&t);//1970年1月1日00：00：01秒早已经过去)

```

正常用法
```c
time_t cur=time(NULL);//获取当前时间
struct timespec t；
t.tvsec=cur+1;//定时1秒
pthread_cond_timedwait(&cond,&mutex,&t);
```

### 唤醒条件变量中等待的线程--->线程离开条件变量会自动上锁
```c
#include <pthread.h>

//单播：随机唤醒（至少）一个在条件变量中的线程
int pthread_cond_signal(pthread_cond_t *cond);
//广播：唤醒所有在条件变量中等待的线程
 int pthread_cond_broadcast(pthread_cond_t *cond);
/* 
参数
    cond    条件变量的地址
返回值：
    成功返回0
    失败返回非0错误码
 */
```

### 销毁条件变量
```c
int pthread_cond_destroy(pthread_cond_t *cond);
/* 
参数
    cond    条件变量的地址
返回值：
    成功返回0
    失败返回非0错误码
 */
```



## TCP通信

### 客户端接口
#### 客户端建立套接字

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

// 建立套接字,返回套接字文件描述符
int socket(int domain, int type, int protocol);
/* 
参数:
    domain    选择地址族
        PF_INET/AF_INET---->IPV4网络协议       
        PF_INET6/AF_INET6--->IPV6网络协议  
    type    哪一种协议
        SOCK_STREAM--TCP流式套接字
        SOCK_DGRAM--UDP数据报套接字
    protocol    
        表示默认协议 一般写0
返回值:
     成功返回 套接字文件描述符 socket_fd
     失败返回 -1 
 */
```
两者在windows下没有任何区别,在linux/unix有细微差别  
PF_INET---Protocol--->在创建套接字的使用  
AF_INET---Address--->结构体定义地址的时候    
但是,对于宏定义而言,他们值都是2

PF_INET 表示协议族（Protocol Family），它是 Protocol Family INET 的缩写。它主要用于套接字创建时选择协议族，用于指定网络层协议（例如IPv4、IPv6等）。在实践中，PF_INET 通常与 SOCK_STREAM 或 SOCK_DGRAM 一起使用，用于创建基于 TCP 或 UDP 的网络套接字。

AF_INET 表示地址族（Address Family），它是 Address Family INET 的缩写。它主要用于套接字地址结构中通过传递地址族参数来指定使用的地址族类型。在实践中，AF_INET 通常与 socket() 和 bind() 等函数一起使用，用于指定使用 IPv4 地址。

理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。

在函数socketpair与socket的domain参数中有AF_UNIX,AF_LOCAL,AF_INET,PF_UNIX,PF_LOCAL,PF_INET.    
这几个参数有AF_UNIX=AF_LOCAL, PF_UNIX=PF_LOCAL, AF_LOCAL=PF_LOCAL,AF_INET=PF_INET.  

**建议:对于socketpair与socket的domain参数,使用PF_LOCAL系列,
而在初始化套接口地址结构时,则使用AF_LOCAL.**  
例如:  
```c
int fd = socket(PF_LOCAL, SOCK_STREAM, 0);  
adr_unix.sin_family = AF_LOCAL; 
```
#### 客户端发起连接

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
/* 
参数
    sockfd
        套接字文件描述符
    addr
        一个结构体,包含对方的IP地址和端口号
    addrlen
        地址的长度-->sizeof(struct sockaddr_in)
返回值:
     成功返回 0
     失败返回 -1 
 */
```
使用`man 7 ip`可以查看
IPV4的结构体
```c

struct sockaddr_in
{
    sa_family_t    sin_family; /* address family: AF_INET 地址族*/
    in_port_t      sin_port;   /* port in network byte order 端口号*/
    struct in_addr sin_addr;   /* internet address IP地址*/
};
 /* Internet address. */
 
struct in_addr
{
    uint32_t   s_addr;   /* address in network byte order无符号整型数据采用大端序 */
};

```
初始化IPV4地址和端口号
```c
// 声明地址和端口的结构体
struct sockaddr_in serverAddr;
// 设置地址蔟
serverAddr.sin_family=AF_INET;
// 设置端口
serverAddr.sin_port=htons(5000);//htons--->将主机端口号变成网络端口号 
// 设置ip地址
serverAddr.sin_addr. s_addr=inet_addr("192.168.1.47");//将主机IP转换为网络IP
// 创建tcp连接
connect(sockfd,(struct sockaddr *)&serverAddr,sizeof( struct sockaddr_in));
```

#### 拓展的函数(地址和端口转换函数)

```c
#include <arpa/inet.h>

uint16_t htons(uint16_t hostshort);//将主机端口号 转成网络端口号
uint16_t ntohs(uint16_t netshort);//将网络端口号 转成主机端口号
```

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

in_addr_t inet_addr(const char *cp);//将主机转化成网络IP
char *inet_ntoa(struct in_addr in);//将网络IP转成主机IP
/* 
参数:
    cp---->主机IP
返回值:
    网络IP    
 */
```


#### 发送数据
```c
#include <sys/types.h>
#include <sys/socket.h>

// 用于网络发数据
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
/* 
参数
    sockfd
        套接字文件描述符
    buf
        你要发送的数据
    len
        你要发送数据的大小,以字节为单位
    flags
        一般默认为0
返回值:
    成功返回    发送的字节数
    失败返回    -1
 */
```
#### 关闭文件
```c
close(fd)
```

### 服务器端API:
#### 绑定自己的IP和端口
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

// 绑定自己的IP地址和端口号
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
/* 
参数
    sockfd
        套接字文件描述符
    addr
        一个结构体,包含对方的IP地址和端口号
    addrlen
        地址的长度-->sizeof(struct sockaddr_in)
返回值:
     成功返回 0
     失败返回 -1 
 */
```
#### 设置铃声/队列
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

// 创建一个未连接的队列,同时最多连接数为backlog
int listen(int sockfd, int backlog);
/* 
参数
    sockfd
        套接字文件描述符
    backlog
        同时最多连接的客户端总数,通常最大为128
返回值:
     成功返回 0
     失败返回 -1 
 */  
```

说明:  
典型的服务器程序可以同时服务于多个客户端,当有客户端发起连接时,服务器调用`accept()`返回并接受这个连接,如果有大量的客户端发起连接而服务器来不及处理,尚未接受的客户端就处于连接等待状态,listen声明sockfd处于监听状态,并且只允许最多backlog个客户端处于连接状态,如果接收到更多的连接请求就忽略.  
查看系统默认的backlog
```bash
cat /proc/sys/net/ipv4/
gec@ubuntu:/proc/sys/net/ipv4$ cat /proc/sys/net/ipv4/tcp_max_syn_backlog 
128
```
#### 等待连接
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
// 等待客户连接
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
/* 
参数
    sockfd
        套接字文件描述符
    addr
        一个结构体,包含对方的IP地址和端口号
    addrlen
        地址的长度-->sizeof(struct sockaddr_in)
返回值:
     成功返回 成功返回已连接的套接字文件描述符
 */

 //如果客户端连接上来,可以获取客户端的IP地址与端口号
```

#### 接收数据
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
/* 
参数
    sockfd
        套接字文件描述符
    buf
        接收到的数据存储位置
    len
        接收的数据长度
    flags
        一般为0
返回值:
    成功返回 接收到的字节数
    失败返回-1
    返回0 表示客户端断开连接
 */
```
<!-- 2023年09月07日 -->
## UDP通信
传输层主要的应用协议模型有两种，一种TCP协议，一种UDP协议。TCP协议占主导地位，绝大多数网络都是借助  
TCP协议完成数据传输，但UDP也是不可或缺的重要通信手段  
相较于TCP,UDP通信形式像发短信。不需要建立连接，维护连接。只需要专心获取数据就可以。省去了三次握手，  
通信速度可以大大提高，伴随着通信的稳定性与正确得不到保障。因此就称之为无连接的不可靠的传输。  
UDP无需连接，开销小，数据传输块，实时性较强，多用于视频会议，电话会议，短视频直播。由于数据的准确率得不到  
保证，为了保证准确性，在应用层添加辅助的校验协议来弥补UDP的不足，以达到可靠传输的目的。

<img src="./img/014-1.png">

由于UDP不需要维护连接，程序逻辑简单明了很多，但是UDP是不可靠的，保证通讯可靠性需要在应用层实现
### 客户端函数
#### 建立套接字
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
/* 
参数:
    domain    选择地址族
        PF_INET/AF_INET---->IPV4网络协议       
        PF_INET6/AF_INET6--->IPV6网络协议  
    type    哪一种协议
        SOCK_STREAM--TCP流式套接字
        SOCK_DGRAM--UDP数据报套接字
    protocol    
        表示默认协议 一般写0
返回值:
     成功返回 套接字文件描述符 socket_fd
     失败返回 -1 
 */
```
#### 发送数据
```c
#include <sys/types.h>
#include <sys/socket.h>

// 用于UDP发送数据，注意是UDP
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                    const struct sockaddr *dest_addr, socklen_t addrlen);
/* 
参数:
    sockfd
        套接字文件描述符
    buf
        你要发送的数据
    len
        你要发送的数据大小，有多少发多少---->strlen
    flags
        一般设置为0
    dest_addr
        对方的IP地址和端口号
    addrlen
        结构体的大小
返回值:
     成功返回发送的字节数
     失败返回 -1 
 */
```

#### 关闭连接
```c
close(socketfd);
```
### 服务器端：
#### 绑定自己的IP和端口号
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

// 绑定自己的IP地址和端口号
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
/* 
参数
    sockfd
        套接字文件描述符
    addr
        一个结构体,包含对方的IP地址和端口号
    addrlen
        地址的长度-->sizeof(struct sockaddr_in)
返回值:
     成功返回 0
     失败返回 -1 
 */
```
#### 接收数据
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t recvfrom(   int sockfd, 
                    void *buf, 
                    size_t len, 
                    int flags,
                    struct sockaddr *src_addr, 
                    socklen_t*addrlen);
/* 
参数
    sockfd
        套接字文件描述符
    buf
        接收到的数组存储在这里
    len
        接收到的数据大小，以最大来接收---->sizeof
    flags
        一般设置为0
    src_addr
        存储客户端的IP地址和端口号，可以获取到是谁发给你的
    addrlen
        结构体的大小
返回值:
     成功返回 接收的字节数
     失败返回 -1 
 */
```

## 广播
### 广播发送方
#### 创建数据报套接字UDP
```c
int socket_fd=socket(PF_INET,SOCK_DGRAM,0);
```
#### 设置socketfd套接字文件的属性为广播。（也就是允许发送广播数据包）
```c
// SO_BROADCAST----->以广播的形式去发送
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

// 用于设置参数sockfd所指定的socket状态
int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
/* 
参数
    sockfd 
        数据报套接字
    level
        欲设置的网络层,一般设置为SOL_SOCKET以存取socket层
    optname    欲设置的选项
        SO_DEBUG 打开或关闭排错模式
        SO_REUSEADDR 允许在 bind ()过程中本地地址可重复使用
        SO_TYPE 返回 socket 形态. 
        SO_ERROR 返回 socket 已发生的错误原因
        SO_DONTROUTE 送出的数据包不要利用路由设备来传输. 
        SO_BROADCAST 使用广播方式传送
        SO_SNDBUF 设置送出的暂存区大小
        SO_RCVBUF 设置接收的暂存区大小
        SO_KEEPALIVE 定期确定连线是否已终止. 
        SO_OOBINLINE 当接收到 OOB 数据时会马上送至标准输入设备
        SO_LINGER 确保数据安全且可靠的传送出去. 
        
        IP_ADD_MEMBERSHIP 组播使用的选项
    optval
        欲设置的值
    optlen
        optval的长度
返回值
    成功返回 0
    失败返回 -1
 */
```

函数使用
```c
int on=1;//将端口设置为可复用
setsockopt(sockfd,SOL_SOCKET,SO_BROADCAST,&on,sizeof(on));//on可以理解为使能，非0的值
```
#### 发送数据，指定接收方为广播地址
```c
struct sockaddr_in sendAddr;
sendAddr.sin_family=AF_INET;
sendAddr.sin_port=htons(10000);
//一定是广播地址 广播地址的主机号全为1
sendAddr.sin_addr.s_addr=inet_addr("192.168.1.255");
// 发送广播数据
sendto(sockfd,buf,strlen(buf),0,(struct sockaddr *)&sendAddr,sizeof(sendAddr));
```
#### 关闭
```c
close();
```
### 广播接收方
#### 创建数据报套接字UDP
```c
int socketfd=socket(PF_INET,SOCK_DGRAM,0);
```
#### 绑定自己的IP
```c
// 注意：绑定的端口必须和发送方指定的端口相同
struct sockaddr_in ownAddr;
ownAddr.sin_family=AF_INET;
//端口
ownAddr.sin_port=htons(10000);
//代表本机所有的地址 INADDR_ANY值为0x00000000
ownAddr.sin_addr.s_addr=htonl(INADDR_ANY);
//uint32_t htonl(uint32_t hostlong);将主机IP转为网络IP
// 绑定地址 能收到本网段的所有消息
bind(socketfd,(struct sockaddr *)&ownAddr,sizeof(struct sockaddr_in));
```
#### 接收数据
```c
recvfrom();
```
#### 关闭
```c
close();
```

## UDP组播
### 概念  
组播介于单播与广播之间，在一个局域网内，将某些主机添加到组中，并设置一个组地址。我们只需要将数据发给组播地址就可以了，加入到这个组的所有主机都能接收到数据。

### 组播的特点
需要给组播设置IP地址，**该ip必须是D类地址**  
只有UDP才能设置组播
### IP地址分类

    D类地址：用于组播
             D类IP地址范围224.0.0.1 -239.255.255.254
    特殊地址：
    每一个字节都为0的地址：（"0.0.0.0"）对应当前主机；
    INADDR_ANY----->代表当前主机所有的地址(有几个网卡就有几个地址)
    127.0.0.1 ---->回环地址（在当前主机内部自动形成闭环的网络）主要用于主机内部不同的应用程序通信
    如果你确定当前的客户端和服务器都是在同一主机上运行，那么就可以使用这个地址。
    
4.接收端怎么接收组播消息？-->需要加入组播属性的套接字
路径：`/usr/include/linux/in.h`
```c
/* Request struct for multicast socket ops */
//组播 结构体
#if __UAPI_DEF_IP_MREQ
struct ip_mreq  {
    struct in_addr imr_multiaddr;    //多播组的IP的地址224.0.0.10
    struct in_addr imr_interface;    //需要加入到组播的ip地址192.168.1.143
};
```
### 组播通信的过程
发送端(和普通UDP通信一样)：  
1. 创建UDP套接字
2. 发送数据到，往组播地址（224.0.0.10）里面发送数据
3. 关闭

接收端：（要把接收端IP地址加入到组播里面）
1. 创建UDP数据报套接字
2. 定义组播结构体
3. 设置组播ip(初始化组播结构体)
4. 加入组播属性（设置这个套接字可以接收组播信息）
5. 绑定地址
6. 接收数据
### 组播函数

#### 定义组播结构体
```c
struct ip_mreq vmreq;
```
#### 设置组播ip(初始化组播结构体)
```c
#include <arpa/inet.h>

int inet_pton(int af, const char *src, void *dst);
作用：将本地的IP地址转换为网络IP地址
参数1：af---->你要选择哪种协议IPV4 AF_INET     还是IPV6--->AFINET6
参数2：src--->本地的IP地址
参数3：dst--->将本机地址转为网络地址存储到这里
```
函数实例
```c
// vmreq.imr_multiaddr=224.0.0.10//错误写法
// vmreq.imr_interface=192.168.1.143//错误写法
inet_pton(AF_INET,"224.0.0.10",&vmreq.imr_multiaddr);//添加组播地址进去
inet_pton(AF_INET,"192.168.1.143",&vmreq.imr_interface);//需要添加到组播的IP地址)(本机ip)
```
#### 加入组播属性（设置这个套接字可以接收组播信息）

```c
//将上面初始化的vmreq组播结构体加入组播属性 IP_ADD_MEMBERSHIP表示组播
setsockopt(socketfd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&vmreq,sizeof(vmreq));
//绑定组播ip
struct sockaddr_in saddr;
saddr.sin_family=AF_INET;
//端口
saddr.sin_port=htons(9999);
//IP地址
saddr.sin_addr.s_addr=htonl(INADDR_ANY);//INADDR_ANY代表所有的地址
bind(socketfd,(struct sockaddr *)&saddr,sizeof(struct sockaddr_in ));
```
#### 接收消息
```c
recvfrom(......);
```
## 字节序转换函数
### 端口字节序转换
```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);

/* 
适用范围:
    在不同主机之间的网络通信,如何是本机的各个程序之间通过网络通信,就不需要转换
函数中字母含义
    字母h代表主机 host
    字母n代表网络 net
    
    后缀字母s代表short    端口号
    后缀字母l代表long    IP地址
 */
```

对于`htonl()`可用看成 *host to net long*   
即 主机转换为网络 ,转成long型
### IP地址字节序转换
```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
// 将一个点分十进制表示的IPv4地址转换为二进制形式，并存储在 inp 中并且返回该网络字节序表示的无符号整数。
int inet_aton(const char *cp, struct in_addr *inp);

// 将一个点分十进制表示的IPv4地址转换为网络字节序的二进制形式。
in_addr_t inet_addr(const char *cp);

// 将一个点分十进制表示的IPv4网络地址（带子网掩码）转换为网络字节序的二进制形式
in_addr_t inet_network(const char *cp);

// 将 struct in_addr 结构体中存储的二进制形式的IPv4地址转换为点分十进制表示的字符串形式，并返回一个指向该字符串的指针。
char *inet_ntoa(struct in_addr in);

// 根据给定的网络地址和主机地址，生成一个新的 struct in_addr 结构体，其中包含组合后的二进制形式的IPv4地址。
struct in_addr inet_makeaddr(in_addr_t net, in_addr_t host);

// 从给定的 struct in_addr 结构体中提取出主机地址（主机位部分），并返回一个 in_addr_t 类型的值。
in_addr_t inet_lnaof(struct in_addr in);

// 从给定的 struct in_addr 结构体中提取出网络地址（网络位部分），并返回一个 in_addr_t 类型的值。
in_addr_t inet_netof(struct in_addr in);
```
### 组播字节序转换
```c
#include <arpa/inet.h>
// 主机地址转网络地址,即将src转换为网络地址并存入dstt中
int inet_pton(int af, const char *src, void *dst);
/* 
参数
    af 选择的协议
        AF_INET ipv4
        AF_INET6 ipv6
    src
        要转换的主机ip
    dst
        转换后的地址存储地方
 */

//网络转主机
const char *inet_ntop(int af, const void *src,char *dst, socklen_t size);
/* 
参数
    af 选择的协议
        AF_INET ipv4
        AF_INET6 ipv6
    src
        转换后的主机ip地址
    dst
        要转换的主机地址
    size
        要转换的大小
 */
```

### 常见实例
```c

struct sockaddr_in own_addr;
own_addr.sin_family = AF_INET;
// 主机端口号转换为网络端口号存储起来
own_addr.sin_port = htons(5123);
// 主机ip转换为网络IP存储起来
own_addr.sin_addr.s_addr = inet_addr("192.168.1.190");
// 当主机地址使用所有网卡的时候 INADDR_ANY表示监听所有网卡
sever_addr.sin_addr.s_addr = htonl(INADDR_ANY);

// 将IP地址和端口打印出来
printf("client ip:%s port:%u \n",inet_ntoa(client_sever.sin_addr),ntohs(client_sever.sin_port));
```

## 服务器编程中性能IO模型

- 阻塞IO   
    同时只能监听一个套接字
- 非阻塞IO   
    一直询问IO口有没有数据达到,浪费CPU资源
- 多路复用   
    让内核监听改变
- 信号驱动   
    使用UDP通信

### 阻塞IO
例如:read/recv函数    
这些函数默认是不具有阻塞属性,而是文件描述符的本身阻塞导致这个函数执行所表现出来的形式是阻塞  
默认情况下,Linux下建立的socket套接字都是阻塞的

读阻塞:当数据缓冲区没有数据可以读取时,就会无线阻塞  
写阻塞:但缓冲区剩余的大小 小于写入的写入的数据量,就会发生写阻塞,直到缓冲区中的数据被读取了

### 非阻塞情况IO
给文件描述符添加非阻塞属性  
由于非阻塞属性,所以不断询问套接字是否有数据到达

#### 给文件描述符设置非阻塞属性
```c
#include <unistd.h>
#include <fcntl.h>

int fcntl(int fd, int cmd, ... /* arg */ );
/* 
参数
    fd
        要设置的文件描述符
    cmd    请求控制命令
        F_GETFL
            获得文件描述符 (void)
        F_SETFL
            设置文件描述符 (int)
    arg
        填 取决于第二个参数
返回值
    成功返回 当cmd命令取下面值的时候返回值
        F_DUPFD
            The new file descriptor.
        F_GETFD
            Value of file descriptor flags.
        F_GETFL
            Value of file status flags.
        F_GETLEASE
            Type of lease held on file descriptor.
        F_GETOWN
            Value of file descriptor owner.
        F_GETSIG
            Value of signal sent when read or write becomes possible, or zero for traditional SIGIO behavior.
        F_GETPIPE_SZ, F_SETPIPE_SZ
            The pipe capacity.
        F_GET_SEALS
            A bit mask identifying the seals that have been set for the inode referred to by fd.
        其他命令返回0
    
    错误返回-1
 */
```
注意:  
O_CREAT,O_EXCL,O_NOCTTY,O_TRUNC 这些状态是不能用fcntl设置  
而O_APPEND,O_ASYNC,O_DIRECT,O_NONBLOCK,O_NOATIME这些状态是可用被设置的

| 描述符     | 描述                 |
| ---------- | -------------------- |
| O_APPEND   | 追加                 |
| O_ASYNC    | 信号触发模式         |
| O_DIRECT   | 不使用缓冲区写入     |
| O_NONBLOCK | 非阻塞属性           |
| O_NOATIME  | 不更改文件的更新时间 |

实例
```c
//打开一个文件
int fd=open("...",...);
// 得到该文件的描述符状态
int status=fcntl(fd,F_GETFL);
// 给该文件描述符添加非阻塞属性
status |= O_NONBLOCK;
// 将该文件添加了非阻塞属性的文件描述符写给原来的文件属性
fcntl(fd,F_SETFL,status);
/* 
同理可以将fd换成套接字的文件描述符
 */
```
特点：

不阻塞，数据一步到位；Proactor模式；
需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；
实现、开发应用难度大；
非常适合高性能高并发应用；



### 多路复用(重点)
#### 多路复用`select()`函数
```c
#include <sys/select.h>
// 对集合中的文件描述符进行监听
// select的调用会阻塞到有文件描述符可以进行IO操作或被信号打断或者超时才会返回
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);
/* 
参数
    nfds
        最大的文件描述符的值+1  
        因此参数会告诉内核检测状态前的文件描述符个数
    readfds
        监听是否有数据到达文件描述符集合(读状态) 表示我们可以读取其中一个文件描述符的数据
    writefds
        监听是否有写数据写入到文件描述符集合(写状态) 表示我们可以写入取其中一个文件描述符的数据
    exceptfds
        需要进行异常事件处理的文件描述符
        监控异常发生到达文件描述符集合中 
    timeout    约束时间的结构体
        NULL    永远的等待下去,就会阻塞,直到有文件描述符发生变化
        设置为timeval    等待固定时间
        均为0    检测文件描述符会立即返回
返回值
    成功    
        返回文件描述符组中发生改变的数量
        超时或者未发生改变 返回 0
    失败    返回-1
当select返回时，每组文件描述符会被select过滤，只留下可以进行对应IO操作的文件描述符
 */
// readfds,writefds,exceptfds这三个参数可以用NULL来表示对应的事件不需要监听。
// readset writeset exceptset指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为NULL。如果三个指针都为NULL，我们就有了一个比sleep()函数更为精确的定时器（sleep()以毫秒为最小单位，这个以微秒为单位）。
// 参数maxfdpl，是所监听的描述符里面值最大的一个再加1的值，注意不是描述符的个数，而是最大值加1，如果我们监听三个描述符，1,3，6，那么maxfdpl的值应该为7.
```
`struct fd_set`可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄，  
这可以是我们所说的普通意义的文件，当然Unix下任何设备、管道、FIFO等都是文件形式，全部包括在内，所以毫无疑问一个socket就是一个文件，socket句柄就是一个文件描述符。  
fd_set集合可以通过一些宏由人为来操作，比如清空集合`FD_ZERO(fd_set *)`等等

select可同时监听的文件描述符数量是通过宏`FS_SETSIZE`来限制的，  
在Linux系统中该值为1024，当然我们可以增大这个值，但随着监听的文件描述符数量增加，select的效率会降低，

fd_set相关函数/宏
```c
// 清除组内相关的fd位
void FD_CLR(int fd, fd_set *set);
// 检测一个文件描述符是否在组中    测试文件描述符集合fd位是否置1    我们用这个来检测一次select调用之后有哪些文件描述符可以进行IO操作
int  FD_ISSET(int fd, fd_set *set);
// 添加一个文件描述符到组中，FD_CLR对应将一个文件描述符移出组中 把文件描述符集合里fd位置1
void FD_SET(int fd, fd_set *set);
// 用来清空文件描述符组  每次调用select前都需要清空一次
void FD_ZERO(fd_set *set);
```
其中的时间参数的结构体 `struct timeval`  
```c
// 秒+微秒都要设置
struct timeval {
    time_t      tv_sec;         /* seconds 秒数*/
    suseconds_t tv_usec;        /* microseconds 微秒数*/
};
```
select使用描述字集，典型地是一个整数数组，其中每个整数中的每一位对应一个描述字。假设使用32位整数，那么该数组的第一个元素对应于描述字0~31，第二个元素对应于描述字32~63，依此类推。所有的实现细节都与应用程序无关，它们隐藏在名为fd_set的数据类型和以下四个宏中：
```c
void FD_ZERO (fd_set *fdset); // clear all bits in fdset
void FD_SET (int fd,fd_set *fdset); // turn on the bit for fd in fdset
void FD_CLR (int fd,fd_set *fdset); // turn off the bit for fd in fdset
int FD_ISSET(int fd,fd_set *fdset); // is the bit for fd on in fd
```
select函数会不断修改timeout的值，所以每次循环都应该重新赋值

[1] 每次调用select，都需要把被监控的fds集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。
[2] 能监听端口的数量有限，单个进程所能打开的最大连接数由`FD_SETSIZE`宏定义，监听上限就等于fds_bits位数组中所有元素的二进制位总数，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上为3264），当然我们可以对宏FD_SETSIZE进行修改，然后重新编译内核，但是性能可能会受到影响，一般该数和系统内存关系很大，具体数目可以`cat /proc/sys/fs/file-max`查看,需要除以1024。32位机默认1024个，64位默认2048。

[3] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件：由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件了。

#### 多路复用`poll()`函数


#### 多路复用`epoll()`函数
##### 创建
```c
#include <sys/epoll.h>

int epoll_create(int size);
int epoll_create1(int flags);
/* 
参数
    size    
        创建的红黑树的监听节点的数量
    flags
返回值
    成功    指向新创建的红黑树的根节点的fd
    失败    -1
 */
```

##### 数据操作
```c
#include <sys/epoll.h>

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
/* 
参数
    epfd
        是epoll_create的句柄,红黑树的根节点
    op    表示动作 用三个宏表示
        EPOLL_CTL_ADD 添加fd到监听红黑树
        EPOLL_CTL_MOD 修改fd在监听红黑树上的监听事件
        EPOLL_CTL_DEL 从监听红黑树上删除节点,也就是取消该文件描述符的监听
    fd
        待加监听的文件描述符
    event
        告诉内核需要监听的事件,需要传入struct epoll_event结构体的地址
返回值
    
 */
```
事件的结构体为
```c
 typedef union epoll_data {
               void        *ptr;
               int          fd;//对应监听事件的fd
               uint32_t     u32;
               uint64_t     u64;
           } epoll_data_t;

           struct epoll_event {
               uint32_t     events;      // Epoll events 
               epoll_data_t data;        // User data variable 
           };
/* 
事件类型
    EPOLLIN
        表示对应的文件描述符可以读
    EPOLLOUT
        表示对应的文件描述符可以写
    EPOLLRDHUP (since Linux 2.6.17)
        表示对应的文件描述符读挂断
    EPOLLPRI
        表示对应的文件描述符有紧急的数据可以读(带外数据)
    EPOLLERR
        表示对应的文件描述符发生错误
    EPOLLHUP
        表示对应的文件描述符被挂断
    EPOLLET
        表示将epoll设置为边缘触发模式
    EPOLLONESHOT (since Linux 2.6.2)
        表示只触发一次事件,当监听完一次事件,如果还需要监听,需要重新把socket加入到队列中
    EPOLLWAKEUP (since Linux 3.5)
    EPOLLEXCLUSIVE (since Linux 4.5)
 */
```
##### 数据等待
```c
#include <sys/epoll.h>

int epoll_wait(int epfd, struct epoll_event *events,
                int maxevents, int timeout);
int epoll_pwait(int epfd, struct epoll_event *events,
                int maxevents, int timeout,
                const sigset_t *sigmask);
/* 
参数
    epfd
        是epoll_create的句柄,红黑树的根节点
    events
        用于存储内核得到的事件集合,实际上就是结构体数组的地址
    maxevents
        告知内核 events有多大,不能超过epoll_create()时的size
    timeout    超时时间
        -1     阻塞
        0    立即返回(非阻塞)
        >0    指定毫秒超时
返回值
    成功    返回有多少个文件描述符就绪    时间到时返回0
    失败    -1
 */

```


#### `select()`,`poll()`,`epoll()`函数的区别
| ---          | select                                                               | poll                                                                 | epoll                                             |
| ------------ | -------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------- |
| 性能         | 随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差 | 随着连接数的增加，性能急剧下降，处理成千上万的并发连接数时，性能很差 | 随着连接数的增加，性能基本没有变化                |
| 连接数       | 一般1024                                                             | 无限制                                                               | 无限制                                            |
| 内存拷贝     | 每次调用select拷贝                                                   | 每次调用poll拷贝                                                     | fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝 |
| 数据结构     | bitmap                                                               | 数组                                                                 | 红黑树                                            |
| 内在处理机制 | 线性轮询                                                             | 线性轮询                                                             | FD挂在红黑树，通过事件回调callback                |
| 时间复杂度   | O(n)                                                                 | O(n)                                                                 | O(1)                                              |

在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。自Linux 2.6内核正式引入epoll以来，epoll已经成为了目前实现高性能网络服务器的必备技术，在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。


#### 触发模式
`select`,`poll`,`epoll`函数都支持水平触发模式,但只有`epoll`同时支持边缘触发模式

一般来说,边缘触发的效率要比水品触发的效率要高,因为边缘触发模式可以减少`epoll_wait`的系统调用次数  
如果使用边缘触发模式,I/O时间发生时只会通知一次,而且我们并不知道应该读取多少数据而让我们遍历所有数据以避免错失读写机会  
所以说会遍历所有文件描述符,而且文件描述符且没有数据读写,则会导致程序阻塞的,

所以边缘触发模式一般和非阻塞I/O搭配使用,程序会一直执行I/o操作,知道系统调用返回错误 

### 信号驱动
属于异步通信  
当socket中有数据达到时,通过发送信号告知用户
特点：回调机制，实现、开发应用难度大；

所谓信号驱动，即用信号来驱使服务器妥善处理多个远端套接字，信号方式的思路比较简单：每当远端有数据到达，那么就在本端触发信号SIGIO，然后利用信号的异步特性来处理远端信息。
```c
void my_fun(int sig)
{
    //读取数据
}
//每次通信的的时候都会触发SIGIO信号,就会调用my_fun函数
signal(SIGIO,my_fun);
```
套接字sockfd----->只要是远端有数据到来，这个信号就会自动产生，捕捉信号就去执行函数读数据出来
#### 适用场景
由于不管套接字收到何种数据，内核一律触发SIGIO，  
因此这种看似理想的方式，却不适合TCP,因为在TCP中，当客户端发来连接请求、普通数据、数据回执等等情况都会触发信号，这就使得服务器端仅凭此信号无法知道下一步要做什么，  
因此信号驱动模型的服务器模型，一般只适用于UDP协议  
### 信号驱动实现步骤  
1. 设置SIGIO的响应函数。信号SIGIO默认会杀死进程，因此必须要设其响应函数，当进程收到信号的时候，说明有数据到达，则在响应函数中接收数据即可。
2. 设置信号SIGIO的属主进程，信号SIGIO由内核针对套接字产生，而内核套接字可以在多个应用程序中有效（例如父子进程将套接字遗传给子进程），因此必须指定该信号属主。
3. 给套接字设置信号触发模式。也就是让套接字工作在信号模式下。因此在默认情况下，套接字收到数据就不会触发SIGIO.必须将套接字文件设定为异步工作模式，它才会触发该信号
#### 如何设置套接字属主---->fcntl()
```c
F_SETOWN (int)--->设置属主
fcntl(sockfd, F_SETOWN, getpid());//sockfd与自己的进程ID绑定在一起  绑定本进程
/*     
Managing signals
F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG and F_SETSIG are used to manage I/O availability signals:

F_GETOWN (void)
            Return  (as  the  function  result) the process ID or process group currently receiving SIGIO and SIGURG signals for events on file descriptor fd.  Process IDs are returned as positive
            values; process group IDs are returned as negative values (but see BUGS below).  arg is ignored.

F_SETOWN (int)
        Set the process ID or process group ID that will receive SIGIO and SIGURG signals for events on file descriptor fd to the ID given in arg.  A process ID  is  specified  as  a  positive
        value; a process group ID is specified as a negative value.  Most commonly, the calling process specifies itself as the owner (that is, arg is specified as getpid(2)).
 */
```
```c
#include <unistd.h>
#include <fcntl.h>

int fcntl(int fd, int cmd, ... /* arg */ );
/* 
参数
    fd
        要设置的文件描述符
    cmd    请求控制命令
        F_GETFL
            获得文件描述符 (void)
        F_SETFL
            设置文件描述符 (int)
    arg
        填 取决于第二个参数
返回值
    成功返回 当cmd命令取下面值的时候返回值
        F_DUPFD
            The new file descriptor.
        F_GETFD
            Value of file descriptor flags.
        F_GETFL
            Value of file status flags.
        F_GETLEASE
            Type of lease held on file descriptor.
        F_GETOWN
            Value of file descriptor owner.
        F_GETSIG
            Value of signal sent when read or write becomes possible, or zero for traditional SIGIO behavior.
        F_GETPIPE_SZ, F_SETPIPE_SZ
            The pipe capacity.
        F_GET_SEALS
            A bit mask identifying the seals that have been set for the inode referred to by fd.
        其他命令返回0
    
    错误返回-1
 */
```
注意:  
O_CREAT,O_EXCL,O_NOCTTY,O_TRUNC 这些状态是不能用fcntl设置  
而O_APPEND,O_ASYNC,O_DIRECT,O_NONBLOCK,O_NOATIME这些状态是可用被设置的

| 描述符     | 描述                 |
| ---------- | -------------------- |
| O_APPEND   | 追加                 |
| O_ASYNC    | 信号触发模式         |
| O_DIRECT   | 不使用缓冲区写入     |
| O_NONBLOCK | 非阻塞属性           |
| O_NOATIME  | 不更改文件的更新时间 |

#### 如何添加信号触发模式属性
```c
int state=fcntl(sockfd,F_GETFL);
state|= O_ASYNC;
fcntl(sockfd,F_SETFL,state);
```

