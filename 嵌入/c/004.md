# 输入输出与循环
## 输入
`int printf("%d",a);`

返回值:返回成功打印字符的个数
## 输出
`int scanf("%d",&a);`

返回值:成功打印字符的个数,一旦有一个项读取失败,那么后面所有的项全部读取失败

### 刷新缓冲区的条件 
1. 输出缓冲区满了的时候
2. 用到\'\n\'会刷新
3. 遇到需要读取的时候会刷新
4. 强制属性输出缓冲区:`fflush(stdout)`
5. 程序结束的时候也会刷新缓冲区

## 浮点数
## 小技巧

`whie(getchar()!='\n')`  
不断的从输入流里面读取字符直到读取到换行号

## 习题
1. 有如下代码：
    ```c
	char c = 200;
	unsigned char uc = 200;  
	printf("c = %hhd\nuc=%hhu\n",c,uc);		//写出打印结果。并说明步骤
    /*    
    输出-56 200
    %hhd 是用来格式化有符号字符型的输出
        c=200   二进制位 1100 1000
        先对c取模,模255
        c的第一位为符号位(1),其余位为数值位(100 1000)
        则输出-56
    %hhu 是用来格式化无符号字符型的输出
        uc=200   二进制位 1100 1000
        先对uc取模,模255
        uc的所有位为数值位(1100 1000)
        则输出200
    */
    ```
2. 有如下代码：
   ```c
	int i = 1.3+1.3;
	printf("i = %f\n",i);		//写出打印结果并分析原因
    /*
        i是int类型,1.3+1.3等于2.6,赋值给int类型会将小数位砍掉
        输出格式又为%f,则不确定输出,
        因为浮点数和整数的存储逻辑不一样
    */
	double d1 = (int)1.3+(int)1.3;
	printf("d1 = %f\n",d1);		//写出打印结果并分析原因
    /*
        强转为int类型时会省略小数点后面,d1=2
        输出格式又为%f,则输出2.00000
    */
	double d2 = 1.3+1.3;
	printf("d2 = %.0f\n",d2);	//写出打印结果并分析原因
    /*
        .0f会进行四舍五入2.6->3
        但是当用%0.f输出2.5时,会输出2,因为浮点数存储是不准确的,2.5可能在计算机中存储是2.49999999
    */
	double d2 = (int)(1.8+1.3);
	printf("d2 = %.0f\n",d2);	//写出打印结果并分析原因
    /*
        使用了int进行强转,会是3
    */
    ```
3. 有如下代码：
    ```c
	short a = 20;
	short i = ++a,a++,2,-a-1;
	printf("a = %hd,i = %hu\n",a,i);	//写出打印结果并分析原因  
    /*
        输出-23   
        (原码)1000 0000 0001 0111  
        => (补码)1111 1111 1110 1001=>(十进制65513)
    */
    ```
4. 如果我想在程序中定义一个int数组arr，但是数组的元素个数在我运行时再指定，应该如何实现？ 
    ```c
    //形如
    int num;
    int nums[num];
    scanf("%d",&num);
    ``` 
    * gcc test.c  -std=c90  
        在编译的时候使用-std指定c语言编译标准,至少要90标准才能支持
    * gcc test.c  -Dbufsize=1024    推荐
        定义了一个名为 bufsize 的宏并赋值为 1024,-D 宏,形如`#define bufsize 1024`
5. 有如下代码：
    ```c
	char buf[11] = "hello world";
	printf("buf = %s\n",buf);		//分析输出结果并说明原因
    
    char buf[11] = "hello world水电费付付付付付付付付付付付付付";
    printf("buf = %s\n",buf);        
    /*输出结果不确定，有可能会发生段错误，原因是数组越界了。一般来说，C语言会保证第一个越界的元素不发生段错误，但是不应该去越界使用*/
    ```
6. 编写程序：提示用户输入一个十进制整数，程序输出这个数的二进制显示。（程序应当提供输入检测，例如输入了非0~9的字符时给出出错提示，并让用户重新输入）
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdbool.h>
    #include <strings.h>
    /*
    1、获取用户输入的十进制字符串，并保存到字符数组中。
    2、遍历数组，查看是否有非法字符，
    如果有就提示用户输入有误，重新输入，
    否则就转换
    不断对原来数字%2,再除2(短除法步骤)
    */
    int main(int)
    {
        char dec[32]="";        //在大括号内并且没有static关键字的变量，是存储在栈上的，他们的值是随机的。
        char bin_tmp[128]="";    //保存转换后的二进制字符中间值
        bool flag = true;        //false:假
        while(1)        
        {
            int i = 0;
            printf("请输入十进制整数：");
            scanf("%31s",dec);    //获取用户输入
            while(dec[i]!='\0')
            {
                if('9'>=dec[i]&&dec[i]>='0')
                ++i;
                else
                {
                    printf("输入的字符包含非十进制字符!\n");
                    bzero(dec,32);                    //清空非法字符
                    flag = false;
                    break;
                }
            }
          if(true==flag)        //根据flag确定循环的退出原因
          {
            //表示输入的数据没有非法字符，开始转二进制并输出到临时数组中
            int dec_num  = atoi(dec);
            int j = 0;
            while(dec_num!=0)
            {
            bin_tmp[j] = dec_num%2+48;
            dec_num/=2;
            ++j;
        }
    //把二进制字符串“倒”过来
            while(j!=0)
            {
                putchar(bin_tmp[--j]);
            }
            putchar('\n');
            bzero(bin_tmp,128);
        }
        else
        {
            flag=true;        //标志位复位
        }
    }
    
    return 0;
    }
    ```

7. 编写程序：升级程序6的功能（重新写一个程序，这里的升级指的是功能升级），程序自动识别输入的数字是十六进制还是十进制，如果是十进制则输出为十六进制输出，如果是十六进制则输出为十进制输出（提示：根据数字的前缀可以区分数字是什么进制），程序也要提供数字验证，例如：12a不是一个合法的数字，0x1x,也不是合法的数字。此时程序应该提示用户重新输入合法的数字。
    ```c
    #include <stdio.h>
    #include <math.h>
    #include <stdlib.h>
    #include <strings.h>
    #include <string.h>
    #define BUFSIZE 64
    int main(void)
    {
        char dec_hex[BUFSIZE]="";            //用于存放用户输入的字符串
        char hex_buf[BUFSIZE]="";            //用于存放转换后的十六进制字符串
        while(1)
        {
            int index = 0;                //表示数组的下标
            //1、获取用户的输入
            printf("请输入十进制或十六进制数字\n");
            scanf("%s",dec_hex);
            //2、判断数字的进制和数字的合法性
            
            if('0'==dec_hex[0]&&('x'==dec_hex[1]||'X'==dec_hex[1]))        //判断是否为十六进制前缀
            {
                //当作十六进制处理
                index = 2;
                while(dec_hex[index]!='\0')
                {
                    if((dec_hex[index]>='0'&&dec_hex[index]<='9')||(dec_hex[index]>='a'&&dec_hex[index]<='f')||(dec_hex[index]>='A'&&dec_hex[index]<='F'))
                        ++index;
                    else
                        break;
                }
                if(dec_hex[index]=='\0')
                {
                    //表示是一个合法的十六进制数，开始转为十进制
                    //1、把十六进制数字转为十进制
                    double conver = 0;                //存放转为10进制的数字
                    int power = 0;
                    while(--index>=2)
                    {
                        if(dec_hex[index]>='0'&&dec_hex[index]<='9')
                        {
                            conver+=(dec_hex[index]-48)*pow(16,power++);
                        }
                        else if((dec_hex[index]>='a'&&dec_hex[index]<='f')||(dec_hex[index]>='A'&&dec_hex[index]<='F'))
                        {
                            switch(dec_hex[index])
                            {
                            case 'a':
                            case 'A':
                                conver+=(10*pow(16,power++));
                                break;
                            case 'b':
                            case 'B':
                                conver+=(11*pow(16,power++));
                                break;
                            case 'c':
                            case 'C':
                                conver+=(12*pow(16,power++));
                                break;
                            case 'd':
                            case 'D':
                                conver+=(13*pow(16,power++));
                                break;
                            case 'e':
                            case 'E':
                                conver+=(14*pow(16,power++));
                                break;
                            case 'f':
                            case 'F':
                                conver+=(15*pow(16,power++));
                            }
                        }
                    }
                    printf("你输入的是十六进制数字，转换为十进制的结果是%.0lf\n",conver);
                    index = 0;
                }
                else
                {
                    printf("输入的进制非法，清重新输入！\n");
                    index = 0;
                    bzero(dec_hex,BUFSIZE);        //从第一个参数的位置开始往后，将后面的第二个参数个数的字节清空为空
                }
            }
            else
            {
                //当作十进制处理
                while(dec_hex[index]!='\0')
                {
                    if(!(dec_hex[index]>='0'&&dec_hex[index]<='9'))
                        break;
                    ++index;
                }
                //判断退出原因：是遍历完数组没有发现异常退出，还是遇到异常字符break;
                if(dec_hex[index]=='\0')        //正常退出：十进制->十六进制    
                {
                    int dec = atoi(dec_hex);
                    int k = 0;
                    char c;
                    while(dec!=0)
                    {
                        c = dec%16;
                        switch(c)
                        {
                        case 15:
                            hex_buf[k++]='f';
                            dec/=16;
                            break;
                        case 14:
                            hex_buf[k++]='e';
                            dec/=16;
                            break;
                        case 13:
                            hex_buf[k++]='d';
                            dec/=16;
                            break;
                        case 12:
                            hex_buf[k++]='c';
                            dec/=16;
                            break;
                        case 11:
                            hex_buf[k++]='b';
                            dec/=16;
                            break;
                        case 10:
                            hex_buf[k++]='a';
                            dec/=16;
                            break;
                        default:
                            hex_buf[k++]=c+48;
                            dec/=16;
                        }
                    }
                    printf("你输入的是十进制数字，转换为十进制的结果是:");
                    while(--k>=0)
                    {
                        putchar(hex_buf[k]);
                    }
                    bzero(dec_hex,BUFSIZE);        //从第一个参数的位置开始往后，将后面的第二个参数个数的字节清空为空
                    putchar('\n');
                }
                else                        //异常退出
                {
                    printf("输入的进制非法，清重新输入！\n");
                    bzero(dec_hex,BUFSIZE);        //从第一个参数的位置开始往后，将后面的第二个参数个数的字节清空为空
                    index = 0;
                }
            }
            
    
        }
        return 0;
    }
    ```
8. 编写身份验证程序，提示用户输入身份证号，程序先校验身份证号是否为合法身份证号（根据身份证的校验码），如果身份证号不合法，则程序拒绝解析。如果身份证号合法，则程序打印用户的
	户籍地址：（如：四川省成都市）
	出生年月日：（如：1997年1月2日）
	性别：（如：男（假定只有两种性别））
    ```c
    #include <stdio.h>
    int main(){
       char idCard[19]="";
       int num[]={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
       char footId[]={'1','0','X','9','8','7','6','5','4','3','2'};
       int total=0;
       while (1)
       {
          printf("请输入身份证号码:");
          scanf("%s",idCard);
          for(int i=0;i<18;i++)
          {
             total+=num[i]* (idCard[i]-48);
          }
          if(footId[total%11]==idCard[17])
          {
             printf("校验通过\n");
          }
          else
          {
             printf("校验不通过!!\n");
          }
       }
       
       return 0;
    }
    ```