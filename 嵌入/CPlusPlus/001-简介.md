<!-- 2023年09月20日 -->
## 简介
c++顾名思义,就是c=c+1,起初为"c with class"  
因此,c++属于c的超集,c++也可以调用已有的c程序库

c++在c语言的基础上添加了面向对象和泛型编程的支持,c++继承了c语言的高效简洁和可移植的传统  

c++融合了3中不同的编程方式
- 面向过程,c语言代表的过程性语言
- 面向对象,c++在c语言基础上添加的类代表的面向对象语言
- 面向泛型,c++模板支持的泛型编程

### 可移植性和标准
假设为运行windows 2000的老式奔腾pc编写了一个很好用的c++程序，而管理员决定使用不同操作系统(比如说Mac OS 或 Linux)和处理器的计算机替换它。该程序是否可在新平台运行呢？当然，但是必须使用为新平台设计的c++编译器重新编译。但是是否需要修改写好的代码？如果不需要修改代码的情况下，重新编译程序后，程序依然运行良好，该程序是可移植的。

程序是否可移植性有两个问题需要解决。
- 第一是硬件，针对特定硬件编程的程序是不可移植的。
- 第二，语言的实现，windows xp c++ 和 Redhat Linux 或 Mac OS X对c++的实现不一定相同。虽然我们希望c++版本与其他版本兼容，但是如果没有一个公开的标准，很难做到。因此，美国国家标准局(AmericanNational Standards Institute,ANSI)在1990年设立一个委员会专门负责制定c++标准(ANSI制定了c语言的标准)。国际标准化组织(International Organization forStandardization，ISO)很快通过自己的委员会加入到这个行列，创建了联合组织ANSI/ISO,制定c++标准。
经过多年的努力，制定出了一个国际标准ISO/IEC14882:1998 ，并于1998年获得了ISO、IEC(International Electrotechnical Committee,国际电工技术委员会)和ANSI的批准。这个标准就是我们经常所说的c++98。它不仅描述了已有的c++特性，还对语言进行了扩展，添加了异常、运行阶段类型识别(RTTI)、模板和标准模板库(STL).

2003年，发布了c++标准第二版(IOS/IEC 14882:2003),这一版本对第一版修订了一些错误，但并没有改变语言特性，因此c++98表示c++98/c++2003.  
c++不断发展。IOS标准委员会于2011年8月批准了新标准ISO/IEC 14882:2011,该标准被称为c++11,与c++98一样c++11也新增了许多特性。  
ISO c++标准还吸收了ANSI c语言标准，c++尽量做到是c的超集。意味着在理想情况下，任何有效的c程序都应该是有效的c++程序。  
ANSI不仅定义了c语言，还定义了一个ANSI c必须实现的标准c库。c++也在使用这个库，另外ANSI/ISO C++标准还提供了一个c++标准类库。 
### 为什么C++会成功
c++最初的目的是将c语言转变为OOP语言，但是c++后来并没有这么做，而是立足于程序的实际。因为在c语言方面大量投入的程序员使其完全丢掉c语言那种编程的思考方式，转而去接受一种新的语言，新的思维，那么将会导致这些程序员中大部分人在短时间内可能毫无成果，使其生产率降低。但是如果让这些c程序员在已有知识的基础上，再去学习c++语言，理解运用OOP，那么也只是在其已有思维的基础上进行扩展而已，这样可以保持其更好的生产率。  
简而言之，强迫程序员放弃c语言和c语言的思考方式，而去转到OOP上是需要代价的，但是从c语言转到c++所花费的代价就会小很多。所以也可以理解为c++的出现并不是去替代c,而是对c的扩展，所以在c++中既可以使用c++新特性，并且可以使用c的过程式思维来编写程序。   

    对于传统的结构化语言，我们向来没有太多的疑惑，函数调用那么自然而明显，只是从程序的某一个地点调到另一个地点去执行。但是对于面向对象(OOP)语言，我们疑惑就会很多。其原因就是C++编译器为我们程序员做了太多隐藏的工作：构造函数，析构函数、虚函数、继承、多态....有时候它为我们合成出一些额外的函数,有时候它又偷偷在我们写的函数里，放进更多的操作。有时候也会给我们的对象里放进一些奇妙的东西，使得我们sizeof的时候结果可我们预期不一样。

## 简单的c++程序
```c
//导入iostream i输入 o输出 stream 流 标准输入输出流文件 等同于c中的stdio.h
#include <iostream>
#include <cstdio>//cstdio包容了stdio.h  c++兼容c的库

using namespace std;//标准命名空间

int main(int argc , char** argv,char** envp)
{
    cout<<"hello word"<<endl;
    /* 
    count 标准输出流  << 流插入运算符
    endl 相对于endline 换行符 
    这两个都在std里面 如果不使用using namespace std; 那么写的时候要用std::cout和std::endl
     */
    return EXIT_SUCCESS;//宏定义的0 防止其他平台的成功返回值不是0
}
```

### c++头文件为什么没有.h？
在c语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是c++得用法改变了，c++头文件没有扩展名。但是有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。例如c++版本的math.h为cmath.
由于C使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如hpp或hxx)表示c++的头文件也是可以的，ANSI/IOS标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不适用任何扩展名。

| 头文件类型  | 约定               | 示例       | 说明                                        |
| ----------- | ------------------ | ---------- | ------------------------------------------- |
| c++旧式风格 | 以.h结尾           | iostream.h | c++程序可用                                 |
| c旧式风格   | 以.h结尾           | math.h     | c/c++程序可用                               |
| c++新式风格 | 无扩展名           | iostream   | c++程序可用，使用namespace std              |
| 转换后的c   | 加上前缀c,无扩展名 | cmath      | c++程序可用，可使用非c特性，如namespace std |

### using namespace std 是什么?
namespace是指标识符的各种可见范围。  
命名空间用关键字namespace 来定义。  
命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。  
简而言之就是给一群相关的变量名进行了分组，不同组（命名空间）之间的变量名的作用域是独立的。以减少命名冲突。
### cout 、endl 是什么？
cout是c++中的标准输出流，endl是输出换行并刷新缓冲区。

## 面向对象三大特性
- 封装 (整合)  
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。  
类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。
- 继承 (改造/升级)  
继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。   
继承的作用：避免公用代码的重复开发，减少代码和数据冗余。
- 多态 (通用接口)  
多态性可以简单地概括为"一个接口，多种方法"，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。（举例：战壕或碉堡和枪口）.