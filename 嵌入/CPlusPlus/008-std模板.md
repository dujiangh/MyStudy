<!-- 2023年10月11日 -->
## STL概论
长久以来,软件界一直希望建立一种可重复利用的东西,以及一种得以制造出”可重复运用的东西”的方法,让程序员的心血不止于随时间的迁移,人事异动而烟消云散,从函数(functions),类别(classes),函数库(function libraries),类别库(class libraries)、各种组件,从模块化设计,到面向对象(objectoriented ),到模式(pattern)的归纳整理,为的就是复用性的提升.  
复用性必须建立在某种标准之上.但是在许多环境下,就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准.大量程序员被迫从事大量重复的工作,竟然是为了完成前人已经完成而自己手上并未拥有的程序代码,这不仅是人力资源的浪费,也是挫折与痛苦的来源.
为了建立数据结构和算法的一套标准,并且降低他们之间的耦合关系,以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL.

### STL基本概念
STL(StandardTemplate Library,标准模板库),是惠普实验室开发的一系列软件的统称.现在主要出现在 c++中,但是在引入 c++之前该技术已经存在很长时间了.         

STL 从广义上分为:容器(container) 算法(algorithm) 迭代器(iterator)  
容器和算法之间通过迭代器进行无缝连接.STL 几乎所有的代码都采用了模板类或者模板函数,这相比传统的由函数和类组成的库来说提供了更好的代码重用机会.STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上.
### STL六大组件简介
STL提供了六大组件,彼此之间可以组合套用,这六大组件分别是:容器、算法、迭代器、仿函数、适配器、空间配置器.
- 容器(Containers)  
    各种数据结构,如vector、list、deque、set、map等,用来存放数据,从实现角度来看,STL容器是一种class template.
- 算法(Algorithm)
    各种常用的算法,如sort、find、copy、for_each.从实现的角度来看,STL算法是一种function tempalte.  
- 迭代器(Iterators)  
    扮演了容器与算法之间的胶合剂,共有五种类型,从实现角度来看,迭代器是一种将operator*, operator-> , operator++,operator--等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器,只有容器的设计者才知道如何遍历自己的元素.原生指针(native pointer)也是一种迭代器.  
- 仿函数(Functors)  
    行为类似函数,可作为算法的某种策略.又称为函数对象(Function Object)是一个能行使函数功能的类.从实现角度来看,仿函数是一种重载了operator()的class 或者class template.
- 适配器(Adapters)  
    一种用来修饰容器或者仿函数或迭代器接口的东西.  
- 空间配置器/分配器(Allocators)  
    负责空间的配置与管理.从实现角度看,配置器是一个实现了动态空间配置、空间管理、空间释放的classtempalte.  

STL六大组件的交互关系,容器通过空间配置器取得数据存储空间,算法通过迭代器存储容器中的内容,仿函数可以协助算法完成不同的策略的变化,适配器可以修饰仿函数.

### STL优点
- STL 是 C++的一部分,因此不用额外安装什么,它被内建在你的编译器之内.
- STL 的一个重要特点是数据结构和算法的分离.尽管这是个简单的概念,但是这种分离使得 STL 变得非常通用.例如:在 STL 的 vector 容器中,可以放入元素、基础数据类型变量、元素的地址；STL 的 sort() 排序函数可以用来操作 vector,list 等容器.
- 程序员可以不用思考 STL 具体的实现过程,只要能够熟练使用 STL 就 OK 了.这样他们就可以把精力放在程序开发的别的方面.
- STL 具有高可重用性,高性能,高移植性,跨平台的优点.
  - 高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现,这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会.关于模板的知识,已经给大家介绍了.
  - 高性能：如 map 可以高效地从十万条记录里面查找出指定的记录,因为 map 是采用红黑树的变体实现的.(红黑树是平横二叉树的一种)
  - 高移植性：如在项目 A 上用 STL 编写的模块,可以直接移植到项目 B 上.    

## STL三大组件
### 容器
研究数据的特定排列方式,以利于搜索或排序或其他特殊目的,这一门学科我们成为数据结构.大学信息类相关专业里面,与编程最有直接关系的学科,首推数据结构与算法.几乎可以说,任何特定的数据结构都是为了实现某种特定的算法.STL容器就是将运用最广泛的一些数据结构实现出来.  

常用的数据结构不在乎,数组(array),链表(list),tree(树),栈(stack),队列(queue),集合(set),映射表(map),根据数据在容器中的排列特性,这些数据分为序列式容器和关联式容器两种.

- 序列式容器就是容器元素在容器中的位置是由元素进入容器的时间和地点来决定.
  - Vector容器
  - Deque容器
  - List容器
  - Stack容器
  - Queue容器.
- 关联式容器是指容器已经有了一定的规则,容器元素在容器中的位置由我的规则来决定.
  - Set/multiset容器 
  - Map/multimap容器


### 算法
以有限的步骤,解决逻辑或数学上的问题,这一门学科我们叫做算法(Algorithms).  
广义而言,我们所编写的每个程序都是一个算法,其中的每个函数也都是一个算法,毕竟它们都是用来解决或大或小的逻辑问题或数学问题.STL收录的算法经过了数学上的效能分析与证明,是极具复用价值的,包括常用的排序,查找等等.特定的算法往往搭配特定的数据结构,数据结构是问题的载体,算法与数据结构相辅相成.  

算法分为:质变算法和非质变算法.
- 质变算法：是指运算过程中会更改区间内的元素的内容.例如拷贝,替换,删除等等
- 非质变算法：是指运算过程中不会更改区间内的元素内容,例如查找、计数、遍历、寻找极值等等  

再好的编程技巧,也无法让一个笨拙的算法起死回生.
### 迭代器
迭代器(iterator)是一种抽象的设计概念,现实程序语言中并没有直接对应于这个概念的实物(可以想象为指针).  
在《Design Patterns》一书中提供了23中设计模式的完整描述,其中iterator模式定义如下：提供一种方法,使之能够依序寻访某个容器所含的各个元素,而又无需暴露该容器的内部表示方式.    
迭代器的设计思维-STL的关键所在,STL的中心思想在于将数据容器(container)和算法(algorithms)分开,彼此独立设计,最后再一贴胶着剂将他们撮合在一起.从技术角度来看,容器和算法的泛型化并不困难,c++的class template和functiontemplate可分别达到目标,如果设计出两这个之间的良好的胶着剂,才是大难题.

迭代器的种类:
| 迭代器         | 功能                               | 支持                                    |
| -------------- | ---------------------------------- | --------------------------------------- |
| 输入迭代器     | 提供对数据的只读访问               | 只读,支持++、==、！=                   |
| 输出迭代器     | 提供对数据的只写访问               | 只写,支持++                            |
| 前向迭代器     | 提供读写操作,并能向前推进迭代器   | 读写,支持++、==、！=                   |
| 双向迭代器     | 提供读写操作,并能向前和向后操作   | 读写,支持++、--,                      |
| 随机访问迭代器 | 提供读写操作,并能在数据中随机移动 | 读写,支持++、--、[n]、-n、<、<=、>、>= |

### 简单案例
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
//打印函数
void fun(int);
int main(int argc, char **argv, char **envp)
{
    // 初始化
    vector<int> num = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
    num.push_back(99);
    // 算法遍历元素
    for_each(num.begin(), num.end(), fun);
    cout << endl;
    // 迭代器遍历元素
    vector<int>::iterator p = num.begin();
    p=p+2;
    p++;
    for (; p != num.end(); p++)
    {
        cout << *p << "  ";
    }
    cout << endl;
    //算法 count 算法 用于统计 某个元素的个数
    int n = count(num.begin(), num.end(),5);
    cout  <<"n:"<< n << endl;
    return 0;
}
void fun(int n)
{
    cout << n << "  ";
}
```
